
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Modules in pybert package &#8212; PyBERT 2.4.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="General description of pybert package." href="intro.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="modules-in-pybert-package">
<h1>Modules in <em>pybert</em> package<a class="headerlink" href="#modules-in-pybert-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pybert-main-pybert-class-definition-as-well-as-some-helper-classes">
<h2>pybert - Main <em>PyBERT</em> class definition, as well as some helper classes.<a class="headerlink" href="#pybert-main-pybert-class-definition-as-well-as-some-helper-classes" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="pybert-cntrl-model-control-logic">
<h2>pybert_cntrl - Model control logic.<a class="headerlink" href="#pybert-cntrl-model-control-logic" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="pybert-view-main-gui-window-layout-definition">
<h2>pybert_view - Main GUI window layout definition.<a class="headerlink" href="#pybert-view-main-gui-window-layout-definition" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pybert.pybert_util">
<span id="pybert-util-various-utilities-used-by-other-modules"></span><h2>pybert_util - Various utilities used by other modules.<a class="headerlink" href="#module-pybert.pybert_util" title="Permalink to this headline">¶</a></h2>
<p>General purpose utilities for PyBERT.</p>
<p>Original author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original date:   September 27, 2014 (Copied from pybert_cntrl.py.)</p>
<p>Copyright (c) 2014 David Banas; all rights reserved World wide.</p>
<dl class="function">
<dt id="pybert.pybert_util.moving_average">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">moving_average</code><span class="sig-paren">(</span><em>a</em>, <em>n=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#moving_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.moving_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a sliding average over the input vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> (<em>[</em><em>float</em><em>]</em>) – Input vector to be averaged.</li>
<li><strong>n</strong> (<em>int</em>) – Width of averaging window, in vector samples. (Optional;
default = 3.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns: the moving average of the input vector, leaving the input</dt>
<dd>vector unchanged.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.find_crossing_times">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">find_crossing_times</code><span class="sig-paren">(</span><em>t</em>, <em>x</em>, <em>min_delay=0.0</em>, <em>rising_first=True</em>, <em>min_init_dev=0.1</em>, <em>thresh=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#find_crossing_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.find_crossing_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the threshold crossing times of the input signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> (<em>[</em><em>float</em><em>]</em>) – Vector of sample times. Intervals do NOT need to be
uniform.</li>
<li><strong>x</strong> (<em>[</em><em>float</em><em>]</em>) – Sampled input vector.</li>
<li><strong>min_delay</strong> (<em>float</em>) – Minimum delay required, before allowing
crossings. (Helps avoid false crossings at beginning of
signal.) (Optional; default = 0.)</li>
<li><strong>rising_first</strong> (<em>bool</em>) – When True, start with the first rising edge
found. (Optional; default = True.) When this option is True,
the first rising edge crossing is the first crossing returned.
This is the desired behavior for PyBERT, because we always
initialize the bit stream with [0, 0, 1, 1], in order to
provide a known synchronization point for jitter analysis.</li>
<li><strong>min_init_dev</strong> (<em>float</em>) – The minimum initial deviation from zero,
which must be detected, before searching for crossings.
Normalized to maximum input signal magnitude.
(Optional; default = 0.1.)</li>
<li><strong>thresh</strong> (<em>float</em>) – Vertical crossing threshold.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: an array of signal threshold crossing times.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.find_crossings">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">find_crossings</code><span class="sig-paren">(</span><em>t</em>, <em>x</em>, <em>amplitude</em>, <em>min_delay=0.0</em>, <em>rising_first=True</em>, <em>min_init_dev=0.1</em>, <em>mod_type=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#find_crossings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.find_crossings" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the crossing times in a signal, according to the modulation type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> (<em>[</em><em>float</em><em>]</em>) – The times associated with each signal sample.</li>
<li><strong>x</strong> (<em>[</em><em>float</em><em>]</em>) – The signal samples.</li>
<li><strong>amplitude</strong> (<em>float</em>) – The nominal signal amplitude. (Used for
determining thresholds, in the case of some modulation
types.)</li>
<li><strong>min_delay</strong> (<em>float</em>) – The earliest possible sample time we want
returned. (Optional; default = 0.)</li>
<li><strong>rising_first</strong> (<em>bool</em>) – When True, start with the first rising edge
found. When this option is True, the first rising edge
crossing is the first crossing returned. This is the desired
behavior for PyBERT, because we always initialize the bit
stream with [0, 1, 1], in order to provide a known
synchronization point for jitter analysis.
(Optional; default = True.)</li>
<li><strong>min_init_dev</strong> (<em>float</em>) – The minimum initial deviation from zero,
which must be detected, before searching for crossings.
Normalized to maximum input signal magnitude.
(Optional; default = 0.1.)</li>
<li><strong>mod_type</strong> (<em>int</em>) – The modulation type. Allowed values are:
{0: NRZ, 1: Duo-binary, 2: PAM-4}
(Optional; default = 0.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: The signal threshold crossing times.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_jitter">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_jitter</code><span class="sig-paren">(</span><em>ui</em>, <em>nui</em>, <em>pattern_len</em>, <em>ideal_xings</em>, <em>actual_xings</em>, <em>rel_thresh=6</em>, <em>num_bins=99</em>, <em>zero_mean=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_jitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the jitter in a set of actual zero crossings, given the ideal crossings and unit interval.</p>
<p>Inputs:</p>
<blockquote>
<div><ul class="simple">
<li>ui               : The nominal unit interval.</li>
<li>nui              : The number of unit intervals spanned by the input signal.</li>
<li>pattern_len      : The number of unit intervals, before input symbol stream repeats.</li>
<li>ideal_xings      : The ideal zero crossing locations of the edges.</li>
<li>actual_xings     : The actual zero crossing locations of the edges.</li>
<li>rel_thresh       : (optional) The threshold for determining periodic jitter spectral components (sigma).</li>
<li>num_bins         : (optional) The number of bins to use, when forming histograms.</li>
<li>zero_mean        : (optional) Force the mean jitter to zero, when True.</li>
</ul>
</div></blockquote>
<p>Outputs:</p>
<blockquote>
<div><ul class="simple">
<li>jitter   : The total jitter.</li>
<li>t_jitter : The times (taken from ‘ideal_xings’) corresponding to the returned jitter values.</li>
<li>isi      : The peak to peak jitter due to intersymbol interference.</li>
<li>dcd      : The peak to peak jitter due to duty cycle distortion.</li>
<li>pj       : The peak to peak jitter due to uncorrelated periodic sources.</li>
<li>rj       : The standard deviation of the jitter due to uncorrelated unbounded random sources.</li>
<li>tie_ind  : The data independent jitter.</li>
<li>thresh   : Threshold for determining periodic components.</li>
<li>jitter_spectrum  : The spectral magnitude of the total jitter.</li>
<li>tie_ind_spectrum : The spectral magnitude of the data independent jitter.</li>
<li>spectrum_freqs   : The frequencies corresponding to the spectrum components.</li>
<li>hist        : The histogram of the actual jitter.</li>
<li>hist_synth  : The histogram of the extrapolated jitter.</li>
<li>bin_centers : The bin center values for both histograms.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.make_uniform">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">make_uniform</code><span class="sig-paren">(</span><em>t</em>, <em>jitter</em>, <em>ui</em>, <em>nbits</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#make_uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.make_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the jitter vector uniformly sampled in time, by zero-filling where necessary.</p>
<p>The trick, here, is creating a uniformly sampled input vector for the FFT operation,
since the jitter samples are almost certainly not uniformly sampled.
We do this by simply zero padding the missing samples.</p>
<p>Inputs:</p>
<ul class="simple">
<li>t      : The sample times for the ‘jitter’ vector.</li>
<li>jitter : The input jitter samples.</li>
<li>ui     : The nominal unit interval.</li>
<li>nbits  : The desired number of unit intervals, in the time domain.</li>
</ul>
<p>Output:</p>
<ul class="simple">
<li>y      : The uniformly sampled, zero padded jitter vector.</li>
<li>y_ix   : The indices where y is valid (i.e. - not zero padded).</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_gamma">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_gamma</code><span class="sig-paren">(</span><em>R0</em>, <em>w0</em>, <em>Rdc</em>, <em>Z0</em>, <em>v0</em>, <em>Theta0</em>, <em>ws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_gamma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates propagation constant from cross-sectional parameters.</p>
<p>The formula’s applied are taken from Howard Johnson’s “Metallic Transmission Model”
(See “High Speed Signal Propagation”, Sec. 3.1.)</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><ul class="first last simple">
<li>R0          skin effect resistance (Ohms/m)</li>
<li>w0          cross-over freq.</li>
<li>Rdc         d.c. resistance (Ohms/m)</li>
<li>Z0          characteristic impedance in LC region (Ohms)</li>
<li>v0          propagation velocity (m/s)</li>
<li>Theta0      loss tangent</li>
<li>ws          frequency sample points vector</li>
</ul>
</dd>
<dt>Outputs:</dt>
<dd><ul class="first last simple">
<li>gamma       frequency dependent propagation constant</li>
<li>Zc          frequency dependent characteristic impedance</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_G">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_G</code><span class="sig-paren">(</span><em>H</em>, <em>Rs</em>, <em>Cs</em>, <em>Zc</em>, <em>RL</em>, <em>Cp</em>, <em>CL</em>, <em>ws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_G"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_G" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates fully loaded transfer function of complete channel.</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><ul class="first last simple">
<li>H     unloaded transfer function of interconnect</li>
<li>Rs    source series resistance</li>
<li>Cs    source parallel (parasitic) capacitance</li>
<li>Zc    frequency dependent characteristic impedance of the interconnect</li>
<li>RL    load resistance (differential)</li>
<li>Cp    load parallel (parasitic) capacitance (single ended)</li>
<li>CL    load series (d.c. blocking) capacitance (single ended)</li>
<li>ws    frequency sample points vector</li>
</ul>
</dd>
<dt>Outputs:</dt>
<dd><ul class="first last simple">
<li>G     frequency dependent transfer function of channel</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_eye">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_eye</code><span class="sig-paren">(</span><em>ui</em>, <em>samps_per_ui</em>, <em>height</em>, <em>ys</em>, <em>y_max</em>, <em>clock_times=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_eye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the “eye” diagram of the input signal vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ui</strong> (<em>float</em>) – unit interval (s)</li>
<li><strong>samps_per_ui</strong> (<em>int</em>) – # of samples per unit interval</li>
<li><strong>height</strong> (<em>int</em>) – height of output image data array</li>
<li><strong>ys</strong> (<em>[</em><em>float</em><em>]</em>) – signal vector of interest</li>
<li><strong>y_max</strong> (<em>float</em>) – max. +/- vertical extremity of plot</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first last"><strong>clock_times</strong> (<em>[</em><em>float</em><em>]</em>) – (optional) vector of clock times to use
for eye centers. If not provided, just use mean
zero-crossing and assume constant UI and no phase jumps.
(This allows the same function to be used for eye diagram
creation, for both pre and post-CDR signals.)</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns: The “heat map” representing the eye diagram. Each grid</dt>
<dd>location contains a value indicating the number of times the
signal passed through that location.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.make_ctle">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">make_ctle</code><span class="sig-paren">(</span><em>rx_bw</em>, <em>peak_freq</em>, <em>peak_mag</em>, <em>w</em>, <em>mode='Passive'</em>, <em>dc_offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#make_ctle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.make_ctle" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the frequency response of a continuous time linear
equalizer (CTLE), given the:</p>
<ul class="simple">
<li>signal path bandwidth,</li>
<li>peaking specification</li>
<li>list of frequencies of interest, and</li>
<li>operational mode/offset.</li>
</ul>
<p>We use the ‘invres()’ function from scipy.signal, as it suggests
itself as a natural approach, given our chosen use model of having
the user provide the peaking frequency and degree of peaking.</p>
<p>That is, we define our desired frequency response using one zero
and two poles, where:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>The pole locations are equal to:</dt>
<dd><ul class="first last">
<li>the signal path natural bandwidth, and</li>
<li>the user specified peaking frequency.</li>
</ul>
</dd>
</dl>
</li>
<li>The zero location is chosen, so as to provide the desired degree
of peaking.</li>
</ul>
<p>Inputs:</p>
<blockquote>
<div><ul class="simple">
<li>rx_bw        The natural (or, unequalized) signal path bandwidth (Hz).</li>
<li><dl class="first docutils">
<dt>peak_freq    The location of the desired peak in the frequency</dt>
<dd>response (Hz).</dd>
</dl>
</li>
<li>peak_mag     The desired relative magnitude of the peak (dB). (mag(H(0)) = 1)</li>
<li>w            The list of frequencies of interest (rads./s).</li>
<li><dl class="first docutils">
<dt>mode         The operational mode; must be one of:</dt>
<dd><ul class="first last">
<li>‘Off’    : CTLE is disengaged.</li>
<li>‘Passive’: Maximum frequency response has magnitude one.</li>
<li>‘AGC’    : Automatic gain control. (Handled by calling routine.)</li>
<li>‘Manual’ : D.C. offset is set manually.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dc_offset    The d.c. offset of the CTLE gain curve (dB).</dt>
<dd>(Only valid, when ‘mode’ = ‘Manual’.)</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Outputs:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>w, H         The resultant complex frequency response, at the</dt>
<dd>given frequencies.</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.trim_impulse">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">trim_impulse</code><span class="sig-paren">(</span><em>g</em>, <em>Ts=0</em>, <em>chnl_dly=0</em>, <em>min_len=0</em>, <em>max_len=1000000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#trim_impulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.trim_impulse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Trim impulse response, for more useful display, by:</dt>
<dd><ul class="first last simple">
<li>clipping off the tail, after 99.8% of the total power has been
captured (Using 99.9% was causing problems; I don’t know why.), and</li>
<li>setting the “front porch” length equal to 20% of the total length.</li>
</ul>
</dd>
<dt>Inputs:</dt>
<dd><ul class="first last simple">
<li>g         impulse response</li>
<li>Ts        (optional) sample interval (same units as ‘chnl_dly’)</li>
<li>chnl_dly  (optional) channel delay</li>
<li>min_len   (optional) minimum length of returned vector</li>
<li>max_len   (optional) maximum length of returned vector</li>
</ul>
</dd>
<dt>Outputs:</dt>
<dd><ul class="first last simple">
<li>g_trim    trimmed impulse response</li>
<li>start_ix  index of first returned sample</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.import_channel">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">import_channel</code><span class="sig-paren">(</span><em>filename</em>, <em>sample_per</em>, <em>padded=False</em>, <em>windowed=False</em>, <em>f_step=10000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#import_channel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.import_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in a channel file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) – Name of file from which to import channel description.</li>
<li><strong>sample_per</strong> (<em>float</em>) – Sample period of signal vector (s).</li>
<li><strong>padded</strong> (<em>Bool</em>) – (Optional) Zero pad s4p data, such that fmax &gt;= 1/(2*sample_per)? (Default = False)</li>
<li><strong>windowed</strong> (<em>Bool</em>) – (Optional) Window s4p data, before converting to time domain? (Default = False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: Imported channel impulse, or step, response.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.interp_time">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">interp_time</code><span class="sig-paren">(</span><em>ts</em>, <em>xs</em>, <em>sample_per</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#interp_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.interp_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample time domain data, using linear interpolation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ts</strong> (<em>[</em><em>float</em><em>]</em>) – Original time values.</li>
<li><strong>xs</strong> (<em>[</em><em>float</em><em>]</em>) – Original signal values.</li>
<li><strong>sample_per</strong> (<em>float</em>) – System sample period.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: Resampled waveform.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.import_time">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">import_time</code><span class="sig-paren">(</span><em>filename</em>, <em>sample_per</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#import_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.import_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in a time domain waveform file, resampling as
appropriate, via linear interpolation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) – Name of waveform file to read in.</li>
<li><strong>sample_per</strong> (<em>float</em>) – New sample interval</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: Resampled waveform.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.sdd_21">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">sdd_21</code><span class="sig-paren">(</span><em>ntwk</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#sdd_21"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.sdd_21" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a 4-port single-ended network, return its differential throughput.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ntwk</strong> (<em>skrf.Network</em>) – 4-port single ended network.</td>
</tr>
</tbody>
</table>
<p>Returns: Sdd[2,1].</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.import_freq">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">import_freq</code><span class="sig-paren">(</span><em>filename</em>, <em>sample_per</em>, <em>padded=False</em>, <em>windowed=False</em>, <em>f_step=10000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#import_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.import_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in a single ended 4-port Touchstone file, and extract the
differential throughput step response, resampling as
appropriate, via linear interpolation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) – Name of Touchstone file to read in.</li>
<li><strong>sample_per</strong> (<em>float</em>) – New sample interval</li>
<li><strong>padded</strong> (<em>Bool</em>) – (Optional) Zero pad s4p data, such that fmax &gt;= 1/(2*sample_per)? (Default = False)</li>
<li><strong>windowed</strong> (<em>Bool</em>) – (Optional) Window s4p data, before converting to time domain? (Default = False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: Resampled step response waveform.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.lfsr_bits">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">lfsr_bits</code><span class="sig-paren">(</span><em>taps</em>, <em>seed</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#lfsr_bits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.lfsr_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of tap indices and a seed, generate a PRBS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>taps</strong> (<em>[</em><em>int</em><em>]</em>) – The set of fed back taps.
(Largest determines order of generator.)</li>
<li><strong>seed</strong> (<em>int</em>) – The initial value of the shift register.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A PRBS generator object with a next() method, for retrieving
the next bit in the sequence.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.safe_log10">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">safe_log10</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#safe_log10"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.safe_log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Guards against pesky ‘Divide by 0’ error messages.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.pulse_center">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">pulse_center</code><span class="sig-paren">(</span><em>p</em>, <em>nspui</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#pulse_center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.pulse_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the center of the pulse response, using the “Hula Hoop”
algorithm (See SiSoft/Tellian’s DesignCon 2016 paper.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p</strong> (<em>[</em><em>Float</em><em>]</em>) – The single bit pulse response.</li>
<li><strong>nspui</strong> (<em>Int</em>) – The number of vector elements per unit interval.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>The estimated index at which the clock will</dt>
<dd><p class="first last">sample the main lobe.</p>
</dd>
<dt>thresh(Float):  The vertical threshold at which the main lobe is</dt>
<dd><p class="first last">UI wide.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">clock_pos(Int)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pybert-plot-plot-definitions-for-the-pybert-gui">
<h2>pybert_plot - Plot definitions for the <em>PyBERT</em> GUI.<a class="headerlink" href="#pybert-plot-plot-definitions-for-the-pybert-gui" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pybert.pybert_help">
<span id="pybert-help-contents-of-the-help-tab-of-the-pybert-gui"></span><h2>pybert_help - Contents of the <em>Help</em> tab of the <em>PyBERT</em> GUI.<a class="headerlink" href="#module-pybert.pybert_help" title="Permalink to this headline">¶</a></h2>
<p>User instructions for PyBERT class.</p>
<p>Original author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original date:   April 15, 2015 (Copied from pybert.py.)</p>
<p>Copyright (c) 2015 David Banas; all rights reserved World wide.</p>
</div>
<div class="section" id="module-pybert.pybert_cfg">
<span id="pybert-cfg-data-structure-for-saving-pybert-configuration"></span><h2>pybert_cfg - Data structure for saving <em>PyBERT</em> configuration.<a class="headerlink" href="#module-pybert.pybert_cfg" title="Permalink to this headline">¶</a></h2>
<p>Simulation configuration data encapsulation, for PyBERT.</p>
<p>Original Author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original Date:   5 May 2017</p>
<p>This Python script provides a data structure for encapsulating the
simulation configuration data of a PyBERT instance. It was first
created, as a way to facilitate easier pickling, so that a particular
configuration could be saved and later restored.</p>
<p>Copyright (c) 2017 by David Banas; All rights reserved World wide.</p>
<dl class="class">
<dt id="pybert.pybert_cfg.PyBertCfg">
<em class="property">class </em><code class="descclassname">pybert.pybert_cfg.</code><code class="descname">PyBertCfg</code><span class="sig-paren">(</span><em>the_PyBERT</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_cfg.html#PyBertCfg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_cfg.PyBertCfg" title="Permalink to this definition">¶</a></dt>
<dd><p>PyBERT simulation configuration data encapsulation class.</p>
<p>This class is used to encapsulate that subset of the configuration
data for a PyBERT instance, which is to be saved when the user
clicks the “Save Config.” button.</p>
</dd></dl>

</div>
<div class="section" id="pybert-data-data-structure-for-saving-pybert-results">
<h2>pybert_data - Data structure for saving <em>PyBERT</em> results.<a class="headerlink" href="#pybert-data-data-structure-for-saving-pybert-results" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pybert.dfe">
<span id="dfe-dfe-behavioral-model"></span><h2>dfe - DFE behavioral model.<a class="headerlink" href="#module-pybert.dfe" title="Permalink to this headline">¶</a></h2>
<p>Behavioral model of a decision feedback equalizer (DFE).</p>
<p>Original Author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original Date:   17 June 2014</p>
<p>This Python script provides a behavioral model of a decision feedback
equalizer (DFE). The class defined, here, is intended for integration
into the larger <em>PyBERT</em> framework.</p>
<p>Copyright (c) 2014 by David Banas; All rights reserved World wide.</p>
<dl class="class">
<dt id="pybert.dfe.LfilterSS">
<em class="property">class </em><code class="descclassname">pybert.dfe.</code><code class="descname">LfilterSS</code><span class="sig-paren">(</span><em>b</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#LfilterSS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.LfilterSS" title="Permalink to this definition">¶</a></dt>
<dd><p>A single steppable version of scipy.signal.lfilter().</p>
<dl class="method">
<dt id="pybert.dfe.LfilterSS.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#LfilterSS.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.LfilterSS.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step the filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>float</em>) – Next input value.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Next output value.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(float)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pybert.dfe.DFE">
<em class="property">class </em><code class="descclassname">pybert.dfe.</code><code class="descname">DFE</code><span class="sig-paren">(</span><em>n_taps</em>, <em>gain</em>, <em>delta_t</em>, <em>alpha</em>, <em>ui</em>, <em>n_spb</em>, <em>decision_scaler</em>, <em>mod_type=0</em>, <em>bandwidth=100000000000.0</em>, <em>n_ave=10</em>, <em>n_lock_ave=500</em>, <em>rel_lock_tol=0.01</em>, <em>lock_sustain=500</em>, <em>ideal=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE" title="Permalink to this definition">¶</a></dt>
<dd><p>Behavioral model of a decision feedback equalizer (DFE).</p>
<dl class="method">
<dt id="pybert.dfe.DFE.decide">
<code class="descname">decide</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE.decide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE.decide" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the bit decisions, according to modulation type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>float</em>) – The signal value, at the decision time.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The members of the returned tuple are:<blockquote>
<div><dl class="docutils">
<dt>decision:</dt>
<dd>One of:<blockquote class="last">
<div><ul class="simple">
<li>{-1, 1}              (NRZ)</li>
<li>{-1, 0, +1}          (Duo-binary)</li>
<li>{-1, -1/3, +1/3, +1} (PAM-4)</li>
</ul>
<p>according to what the ideal signal level should have been.
(‘decision_scaler’ normalized)</p>
</div></blockquote>
</dd>
</dl>
<p>bits: The list of bits recovered.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple(float, [int])</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code> – If the requested modulation type is unknown.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pybert.dfe.DFE.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>sample_times</em>, <em>signal</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the DFE on the input signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sample_times</strong> (<em>[</em><em>float</em><em>]</em>) – Vector of time values at wich
corresponding signal values were sampled.</li>
<li><strong>signal</strong> (<em>[</em><em>float</em><em>]</em>) – Vector of sampled signal values.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>The members of the returned tuple, in order, are:</p>
<blockquote>
<div><dl class="docutils">
<dt>res([float]):</dt>
<dd><p class="first last">Samples of the summing node output, taken at the
times given in <em>sample_times</em>.</p>
</dd>
<dt>tap_weights([[float]]):</dt>
<dd><p class="first last">List of list of tap weights showing how the DFE
adapted over time.</p>
</dd>
<dt>ui_ests([float]):</dt>
<dd><p class="first last">List of unit interval estimates, showing how the
CDR adapted.</p>
</dd>
<dt>clocks([int]):</dt>
<dd><p class="first last">List of mostly zeros with ones at the recovered
clocking instants. Useful for overlaying the
clock times on signal waveforms, in plots.</p>
</dd>
<dt>lockeds([bool]):</dt>
<dd><p class="first last">List of Booleans indicating state of CDR lock.</p>
</dd>
<dt>clock_times([float]):</dt>
<dd><p class="first last">List of clocking instants, as recovered by the CDR.</p>
</dd>
<dt>bits([int]):</dt>
<dd><p class="first last">List of recovered bits.</p>
</dd>
</dl>
</div></blockquote>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple(([float], [[float]], [float], [int], [bool], [float], [int]))</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code> – If the requested modulation type is unknown.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pybert.dfe.DFE.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>decision</em>, <em>error</em>, <em>update</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step the DFE, according to the new decision and error inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>decision</strong> (<em>float</em>) – Current slicer output.</li>
<li><strong>error</strong> (<em>float</em>) – Difference between summing node and slicer outputs.</li>
<li><strong>update</strong> (<em>bool</em>) – If true, update tap weights.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New backward filter output value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">res(float)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pybert.cdr">
<span id="cdr-cdr-behavioral-model"></span><h2>cdr - CDR behavioral model.<a class="headerlink" href="#module-pybert.cdr" title="Permalink to this headline">¶</a></h2>
<p>Behavioral model of a “bang-bang” clock data recovery (CDR) unit.</p>
<p>Original Author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original Date:   17 June 2014</p>
<p>This Python script provides a behavioral model of a “bang-bang” clock
data recovery (CDR) unit. The class defined, here, is intended for
integration into the larger <em>PyBERT</em> framework.</p>
<p>Copyright (c) 2014 by David Banas; All rights reserved World wide.</p>
<dl class="class">
<dt id="pybert.cdr.CDR">
<em class="property">class </em><code class="descclassname">pybert.cdr.</code><code class="descname">CDR</code><span class="sig-paren">(</span><em>delta_t</em>, <em>alpha</em>, <em>ui</em>, <em>n_lock_ave=500</em>, <em>rel_lock_tol=0.01</em>, <em>lock_sustain=500</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/cdr.html#CDR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.cdr.CDR" title="Permalink to this definition">¶</a></dt>
<dd><p>A class providing behavioral modeling of a ‘bang- bang’ clock
data recovery (CDR) unit.</p>
<dl class="method">
<dt id="pybert.cdr.CDR.adapt">
<code class="descname">adapt</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/cdr.html#CDR.adapt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.cdr.CDR.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapt period/phase, according to 3 samples.</p>
<p>Should be called, when the clock has just struck.</p>
<dl class="docutils">
<dt>Synopsis:</dt>
<dd>(ui, locked) = adapt(samples)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>[</em><em>float</em><em>]</em>) – <p>A list of 3 samples of the input waveform, as follows:</p>
<ul class="simple">
<li>at the last clock time</li>
<li>at the last unit interval boundary time</li>
<li>at the current clock time</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>ui:</dt>
<dd>The new unit interval estimate, in seconds.</dd>
<dt>locked:</dt>
<dd>Boolean flag indicating ‘locked’ status.</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple (float, bool)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pybert.cdr.CDR.locked">
<code class="descname">locked</code><a class="headerlink" href="#pybert.cdr.CDR.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>The current locked state.</p>
</dd></dl>

<dl class="attribute">
<dt id="pybert.cdr.CDR.ui">
<code class="descname">ui</code><a class="headerlink" href="#pybert.cdr.CDR.ui" title="Permalink to this definition">¶</a></dt>
<dd><p>The current unit interval estimate.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PyBERT</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">General description of <em>pybert</em> package.</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modules in <em>pybert</em> package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pybert-main-pybert-class-definition-as-well-as-some-helper-classes">pybert - Main <em>PyBERT</em> class definition, as well as some helper classes.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pybert-cntrl-model-control-logic">pybert_cntrl - Model control logic.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pybert-view-main-gui-window-layout-definition">pybert_view - Main GUI window layout definition.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pybert.pybert_util">pybert_util - Various utilities used by other modules.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pybert-plot-plot-definitions-for-the-pybert-gui">pybert_plot - Plot definitions for the <em>PyBERT</em> GUI.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pybert.pybert_help">pybert_help - Contents of the <em>Help</em> tab of the <em>PyBERT</em> GUI.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pybert.pybert_cfg">pybert_cfg - Data structure for saving <em>PyBERT</em> configuration.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pybert-data-data-structure-for-saving-pybert-results">pybert_data - Data structure for saving <em>PyBERT</em> results.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pybert.dfe">dfe - DFE behavioral model.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pybert.cdr">cdr - CDR behavioral model.</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="intro.html" title="previous chapter">General description of <em>pybert</em> package.</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, David Banas.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/modules.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>