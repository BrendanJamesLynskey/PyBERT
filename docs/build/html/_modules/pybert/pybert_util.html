
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pybert.pybert_util &#8212; PyBERT 3.3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pybert.pybert_util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">General purpose utilities for PyBERT.</span>

<span class="sd">Original author: David Banas &lt;capn.freako@gmail.com&gt;</span>

<span class="sd">Original date:   September 27, 2014 (Copied from pybert_cntrl.py.)</span>

<span class="sd">Copyright (c) 2014 David Banas; all rights reserved World wide.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">pkgutil</span>
<span class="kn">import</span> <span class="nn">importlib</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">array</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">,</span>
    <span class="n">convolve</span><span class="p">,</span>
    <span class="n">cumsum</span><span class="p">,</span>
    <span class="n">diff</span><span class="p">,</span>
    <span class="nb">float</span><span class="p">,</span>
    <span class="n">histogram</span><span class="p">,</span>
    <span class="n">insert</span><span class="p">,</span>
    <span class="n">log10</span><span class="p">,</span>
    <span class="n">mean</span><span class="p">,</span>
    <span class="n">ones</span><span class="p">,</span>
    <span class="n">pi</span><span class="p">,</span>
    <span class="n">power</span><span class="p">,</span>
    <span class="n">real</span><span class="p">,</span>
    <span class="n">reshape</span><span class="p">,</span>
    <span class="n">resize</span><span class="p">,</span>
    <span class="n">sign</span><span class="p">,</span>
    <span class="n">sort</span><span class="p">,</span>
    <span class="n">sqrt</span><span class="p">,</span>
    <span class="n">where</span><span class="p">,</span>
    <span class="n">zeros</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="k">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">get_window</span><span class="p">,</span> <span class="n">invres</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">skrf</span> <span class="k">as</span> <span class="nn">rf</span>

<span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">gDebugOptimize</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">gMaxCTLEPeak</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># max. allowed CTLE peaking (dB) (when optimizing, only)</span>


<div class="viewcode-block" id="moving_average"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.moving_average">[docs]</a><span class="k">def</span> <span class="nf">moving_average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a sliding average over the input vector.</span>

<span class="sd">    Args:</span>
<span class="sd">        a([float]): Input vector to be averaged.</span>
<span class="sd">        n(int): Width of averaging window, in vector samples. (Optional;</span>
<span class="sd">            default = 3.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: the moving average of the input vector, leaving the input</span>
<span class="sd">            vector unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ret</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ret</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">n</span></div>


<div class="viewcode-block" id="find_crossing_times"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.find_crossing_times">[docs]</a><span class="k">def</span> <span class="nf">find_crossing_times</span><span class="p">(</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">min_delay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">rising_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">min_init_dev</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">thresh</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the threshold crossing times of the input signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        t([float]): Vector of sample times. Intervals do NOT need to be</span>
<span class="sd">            uniform.</span>
<span class="sd">        x([float]): Sampled input vector.</span>
<span class="sd">        min_delay(float): Minimum delay required, before allowing</span>
<span class="sd">            crossings. (Helps avoid false crossings at beginning of</span>
<span class="sd">            signal.) (Optional; default = 0.)</span>
<span class="sd">        rising_first(bool): When True, start with the first rising edge</span>
<span class="sd">            found. (Optional; default = True.) When this option is True,</span>
<span class="sd">            the first rising edge crossing is the first crossing returned.</span>
<span class="sd">            This is the desired behavior for PyBERT, because we always</span>
<span class="sd">            initialize the bit stream with [0, 0, 1, 1], in order to</span>
<span class="sd">            provide a known synchronization point for jitter analysis.</span>
<span class="sd">        min_init_dev(float): The minimum initial deviation from zero,</span>
<span class="sd">            which must be detected, before searching for crossings.</span>
<span class="sd">            Normalized to maximum input signal magnitude.</span>
<span class="sd">            (Optional; default = 0.1.)</span>
<span class="sd">        thresh(float): Vertical crossing threshold.</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: Array of signal threshold crossing times.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(t) (</span><span class="si">%d</span><span class="s2">) and len(x) (</span><span class="si">%d</span><span class="s2">) need to be the same.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">max_mag_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(x):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">raise</span>
    <span class="n">min_mag_x</span> <span class="o">=</span> <span class="n">min_init_dev</span> <span class="o">*</span> <span class="n">max_mag_x</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">min_mag_x</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;Input signal minimum deviation not detected!&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">-</span> <span class="n">thresh</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>

    <span class="n">sign_x</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">sign_x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">sign_x</span><span class="p">,</span> <span class="n">sign_x</span><span class="p">,</span> <span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sign_x</span><span class="p">)))</span>  <span class="c1"># &quot;0&quot;s can produce duplicate xings.</span>
    <span class="n">diff_sign_x</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">sign_x</span><span class="p">)</span>
    <span class="n">xing_ix</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">diff_sign_x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xings</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xing_ix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">xings</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([])</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">min_delay</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">min_delay</span> <span class="o">&lt;</span> <span class="n">xings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;min_delay (</span><span class="si">{}</span><span class="s2">) must be less than last crossing time (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">min_delay</span><span class="p">,</span> <span class="n">xings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">while</span> <span class="n">xings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_delay</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;min_delay: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_delay</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rising_first: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rising_first</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;max_mag_x: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_mag_x</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;min_mag_x: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_mag_x</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;xings[0]: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xings</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;xings[i]: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xings</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rising_first</span> <span class="ow">and</span> <span class="n">diff_sign_x</span><span class="p">[</span><span class="n">xing_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(diff_sign_x):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_sign_x</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(xing_ix):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xing_ix</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">raise</span>

    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">xings</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span></div>


<div class="viewcode-block" id="find_crossings"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.find_crossings">[docs]</a><span class="k">def</span> <span class="nf">find_crossings</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">min_delay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">rising_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">min_init_dev</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">mod_type</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the crossing times in a signal, according to the modulation type.</span>

<span class="sd">    Args:</span>
<span class="sd">        t([float]): The times associated with each signal sample.</span>
<span class="sd">        x([float]): The signal samples.</span>
<span class="sd">        amplitude(float): The nominal signal amplitude. (Used for</span>
<span class="sd">            determining thresholds, in the case of some modulation</span>
<span class="sd">            types.)</span>
<span class="sd">        min_delay(float): The earliest possible sample time we want</span>
<span class="sd">            returned. (Optional; default = 0.)</span>
<span class="sd">        rising_first(bool): When True, start with the first rising edge</span>
<span class="sd">            found. When this option is True, the first rising edge</span>
<span class="sd">            crossing is the first crossing returned. This is the desired</span>
<span class="sd">            behavior for PyBERT, because we always initialize the bit</span>
<span class="sd">            stream with [0, 1, 1], in order to provide a known</span>
<span class="sd">            synchronization point for jitter analysis.</span>
<span class="sd">            (Optional; default = True.)</span>
<span class="sd">        min_init_dev(float): The minimum initial deviation from zero,</span>
<span class="sd">            which must be detected, before searching for crossings.</span>
<span class="sd">            Normalized to maximum input signal magnitude.</span>
<span class="sd">            (Optional; default = 0.1.)</span>
<span class="sd">        mod_type(int): The modulation type. Allowed values are:</span>
<span class="sd">            {0: NRZ, 1: Duo-binary, 2: PAM-4}</span>
<span class="sd">            (Optional; default = 0.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: The signal threshold crossing times.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">mod_type</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mod_type</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;ERROR: pybert_util.find_crossings(): Unknown modulation type: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">mod_type</span>
    <span class="p">)</span>

    <span class="n">xings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># NRZ</span>
        <span class="n">xings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">find_crossing_times</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">min_delay</span><span class="o">=</span><span class="n">min_delay</span><span class="p">,</span> <span class="n">rising_first</span><span class="o">=</span><span class="n">rising_first</span><span class="p">,</span> <span class="n">min_init_dev</span><span class="o">=</span><span class="n">min_init_dev</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Duo-binary</span>
        <span class="n">xings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">find_crossing_times</span><span class="p">(</span>
                <span class="n">t</span><span class="p">,</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">min_delay</span><span class="o">=</span><span class="n">min_delay</span><span class="p">,</span>
                <span class="n">rising_first</span><span class="o">=</span><span class="n">rising_first</span><span class="p">,</span>
                <span class="n">min_init_dev</span><span class="o">=</span><span class="n">min_init_dev</span><span class="p">,</span>
                <span class="n">thresh</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">amplitude</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">xings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">find_crossing_times</span><span class="p">(</span>
                <span class="n">t</span><span class="p">,</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">min_delay</span><span class="o">=</span><span class="n">min_delay</span><span class="p">,</span>
                <span class="n">rising_first</span><span class="o">=</span><span class="n">rising_first</span><span class="p">,</span>
                <span class="n">min_init_dev</span><span class="o">=</span><span class="n">min_init_dev</span><span class="p">,</span>
                <span class="n">thresh</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">amplitude</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">mod_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># PAM-4 (Enabling the +/-0.67 cases yields multiple ideal crossings at the same edge.)</span>
        <span class="n">xings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">find_crossing_times</span><span class="p">(</span>
                <span class="n">t</span><span class="p">,</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">min_delay</span><span class="o">=</span><span class="n">min_delay</span><span class="p">,</span>
                <span class="n">rising_first</span><span class="o">=</span><span class="n">rising_first</span><span class="p">,</span>
                <span class="n">min_init_dev</span><span class="o">=</span><span class="n">min_init_dev</span><span class="p">,</span>
                <span class="n">thresh</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span> <span class="o">*</span> <span class="n">amplitude</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Unknown modulation type: </span><span class="si">{mod_type}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sort</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="n">xings</span><span class="p">))</span></div>


<div class="viewcode-block" id="calc_jitter"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.calc_jitter">[docs]</a><span class="k">def</span> <span class="nf">calc_jitter</span><span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">nui</span><span class="p">,</span> <span class="n">pattern_len</span><span class="p">,</span> <span class="n">ideal_xings</span><span class="p">,</span> <span class="n">actual_xings</span><span class="p">,</span> <span class="n">rel_thresh</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">zero_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the jitter in a set of actual zero crossings, given the ideal crossings and unit interval.</span>

<span class="sd">    Inputs:</span>

<span class="sd">      - ui               : The nominal unit interval.</span>
<span class="sd">      - nui              : The number of unit intervals spanned by the input signal.</span>
<span class="sd">      - pattern_len      : The number of unit intervals, before input symbol stream repeats.</span>
<span class="sd">      - ideal_xings      : The ideal zero crossing locations of the edges.</span>
<span class="sd">      - actual_xings     : The actual zero crossing locations of the edges.</span>
<span class="sd">      - rel_thresh       : (optional) The threshold for determining periodic jitter spectral components (sigma).</span>
<span class="sd">      - num_bins         : (optional) The number of bins to use, when forming histograms.</span>
<span class="sd">      - zero_mean        : (optional) Force the mean jitter to zero, when True.</span>

<span class="sd">    Outputs:</span>

<span class="sd">      - jitter   : The total jitter.</span>
<span class="sd">      - t_jitter : The times (taken from &#39;ideal_xings&#39;) corresponding to the returned jitter values.</span>
<span class="sd">      - isi      : The peak to peak jitter due to intersymbol interference.</span>
<span class="sd">      - dcd      : The peak to peak jitter due to duty cycle distortion.</span>
<span class="sd">      - pj       : The peak to peak jitter due to uncorrelated periodic sources.</span>
<span class="sd">      - rj       : The standard deviation of the jitter due to uncorrelated unbounded random sources.</span>
<span class="sd">      - tie_ind  : The data independent jitter.</span>
<span class="sd">      - thresh   : Threshold for determining periodic components.</span>
<span class="sd">      - jitter_spectrum  : The spectral magnitude of the total jitter.</span>
<span class="sd">      - tie_ind_spectrum : The spectral magnitude of the data independent jitter.</span>
<span class="sd">      - spectrum_freqs   : The frequencies corresponding to the spectrum components.</span>
<span class="sd">      - hist        : The histogram of the actual jitter.</span>
<span class="sd">      - hist_synth  : The histogram of the extrapolated jitter.</span>
<span class="sd">      - bin_centers : The bin center values for both histograms.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">my_hist</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the probability mass function (PMF) of the input vector,</span>
<span class="sd">        enforcing an output range of [-UI/2, +UI/2], sweeping everything in [-UI, -UI/2] into the first bin,</span>
<span class="sd">        and everything in [UI/2, UI] into the last bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">ui</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="n">ui</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ui</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_bins</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ui</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="o">-</span><span class="n">ui</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">mean</span><span class="p">([</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ui</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">hist</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">hist</span><span class="p">),</span> <span class="n">bin_centers</span><span class="p">)</span>

    <span class="c1"># Check inputs.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ideal_xings</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;calc_jitter(): zero length ideal crossings vector received!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">actual_xings</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;calc_jitter(): zero length actual crossings vector received!&quot;</span><span class="p">)</span>

    <span class="c1"># Line up first ideal/actual crossings, and count/validate crossings per pattern.</span>
    <span class="n">ideal_xings</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ideal_xings</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">ideal_xings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ui</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">actual_xings</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">actual_xings</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">actual_xings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ui</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">xings_per_pattern</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">ideal_xings</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">pattern_len</span> <span class="o">*</span> <span class="n">ui</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xings_per_pattern</span> <span class="o">%</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">xings_per_pattern</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;xings_per_pattern:&quot;</span><span class="p">,</span> <span class="n">xings_per_pattern</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(ideal_xings):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ideal_xings</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;min(ideal_xings):&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ideal_xings</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;max(ideal_xings):&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ideal_xings</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;pybert_util.calc_jitter(): Odd number of (or, no) crossings per pattern detected!&quot;</span><span class="p">)</span>
    <span class="n">num_patterns</span> <span class="o">=</span> <span class="n">nui</span> <span class="o">//</span> <span class="n">pattern_len</span>

    <span class="c1"># Assemble the TIE track.</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">jitter</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t_jitter</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">skip_next_ideal_xing</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">ideal_xing</span> <span class="ow">in</span> <span class="n">ideal_xings</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">skip_next_ideal_xing</span><span class="p">:</span>
            <span class="n">t_jitter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ideal_xing</span><span class="p">)</span>
            <span class="n">skip_next_ideal_xing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">continue</span>
        <span class="c1"># Confine our attention to those actual crossings occuring</span>
        <span class="c1"># within the interval [-UI/2, +UI/2] centered around the</span>
        <span class="c1"># ideal crossing.</span>
        <span class="n">min_t</span> <span class="o">=</span> <span class="n">ideal_xing</span> <span class="o">-</span> <span class="n">ui</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">max_t</span> <span class="o">=</span> <span class="n">ideal_xing</span> <span class="o">+</span> <span class="n">ui</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">actual_xings</span><span class="p">)</span> <span class="ow">and</span> <span class="n">actual_xings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_t</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">actual_xings</span><span class="p">):</span>  <span class="c1"># We&#39;ve exhausted the list of actual crossings; we&#39;re done.</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">actual_xings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_t</span><span class="p">:</span>  <span class="c1"># Means the xing we&#39;re looking for didn&#39;t occur, in the actual signal.</span>
            <span class="n">jitter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ui</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">)</span>  <span class="c1"># Pad the jitter w/ alternating +/- 3UI/4.</span>
            <span class="n">jitter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ui</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">)</span>  <span class="c1"># (Will get pulled into [-UI/2, UI/2], later.</span>
            <span class="n">skip_next_ideal_xing</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># If we missed one, we missed two.</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Noise may produce several crossings. We find all those</span>
            <span class="n">xings</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># within the interval [-UI/2, +UI/2] centered</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># around the ideal crossing, and take the average.</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">actual_xings</span><span class="p">)</span> <span class="ow">and</span> <span class="n">actual_xings</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">max_t</span><span class="p">:</span>
                <span class="n">xings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">actual_xings</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">tie</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">xings</span><span class="p">)</span> <span class="o">-</span> <span class="n">ideal_xing</span>
            <span class="n">jitter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tie</span><span class="p">)</span>
        <span class="n">t_jitter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ideal_xing</span><span class="p">)</span>
    <span class="n">jitter</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mean(jitter):&quot;</span><span class="p">,</span> <span class="n">mean</span><span class="p">(</span><span class="n">jitter</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(jitter):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">zero_mean</span><span class="p">:</span>
        <span class="n">jitter</span> <span class="o">-=</span> <span class="n">mean</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span>

    <span class="c1"># Do the jitter decomposition.</span>
    <span class="c1"># - Separate the rising and falling edges, shaped appropriately for averaging over the pattern period.</span>
    <span class="n">tie_risings</span> <span class="o">=</span> <span class="n">jitter</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">),</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="n">tie_fallings</span> <span class="o">=</span> <span class="n">jitter</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">),</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="n">tie_risings</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_patterns</span> <span class="o">*</span> <span class="n">xings_per_pattern</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">tie_fallings</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_patterns</span> <span class="o">*</span> <span class="n">xings_per_pattern</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">tie_risings</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">tie_risings</span><span class="p">,</span> <span class="p">(</span><span class="n">num_patterns</span><span class="p">,</span> <span class="n">xings_per_pattern</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">tie_fallings</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">tie_fallings</span><span class="p">,</span> <span class="p">(</span><span class="n">num_patterns</span><span class="p">,</span> <span class="n">xings_per_pattern</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># - Use averaging to remove the uncorrelated components, before calculating data dependent components.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tie_risings_ave</span> <span class="o">=</span> <span class="n">tie_risings</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tie_fallings_ave</span> <span class="o">=</span> <span class="n">tie_fallings</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">isi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tie_risings_ave</span><span class="o">.</span><span class="n">ptp</span><span class="p">(),</span> <span class="n">tie_fallings_ave</span><span class="o">.</span><span class="n">ptp</span><span class="p">())</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;xings_per_pattern:&quot;</span><span class="p">,</span> <span class="n">xings_per_pattern</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(ideal_xings):&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ideal_xings</span><span class="p">))</span>
        <span class="k">raise</span>
    <span class="n">isi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">isi</span><span class="p">,</span> <span class="n">ui</span><span class="p">)</span>  <span class="c1"># Cap the ISI at the unit interval.</span>
    <span class="n">dcd</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">tie_risings_ave</span><span class="p">)</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="n">tie_fallings_ave</span><span class="p">))</span>

    <span class="c1"># - Subtract the data dependent jitter from the original TIE track, in order to yield the data independent jitter.</span>
    <span class="n">tie_ave</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tie_risings_ave</span><span class="p">,</span> <span class="n">tie_fallings_ave</span><span class="p">)),</span> <span class="p">())</span>
    <span class="n">tie_ave</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">tie_ave</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">))</span>
    <span class="n">tie_ind</span> <span class="o">=</span> <span class="n">jitter</span> <span class="o">-</span> <span class="n">tie_ave</span>

    <span class="c1"># - Use spectral analysis to help isolate the periodic components of the data independent jitter.</span>
    <span class="c1"># -- Calculate the total jitter spectrum, for display purposes only.</span>
    <span class="c1"># --- Make vector uniformly sampled in time, via zero padding where necessary.</span>
    <span class="c1"># --- (It&#39;s necessary to keep track of those elements in the resultant vector, which aren&#39;t paddings; hence, &#39;valid_ix&#39;.)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">valid_ix</span> <span class="o">=</span> <span class="n">make_uniform</span><span class="p">(</span><span class="n">t_jitter</span><span class="p">,</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">nui</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">jitter_spectrum</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">))</span>  <span class="c1"># Normalized, in order to make power correct.</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">ui</span> <span class="o">*</span> <span class="n">nui</span><span class="p">)</span>
    <span class="n">spectrum_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">f0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="c1"># -- Use the data independent jitter spectrum for our calculations.</span>
    <span class="n">tie_ind_uniform</span><span class="p">,</span> <span class="n">valid_ix</span> <span class="o">=</span> <span class="n">make_uniform</span><span class="p">(</span><span class="n">t_jitter</span><span class="p">,</span> <span class="n">tie_ind</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">nui</span><span class="p">)</span>

    <span class="c1"># --- Normalized, in order to make power correct, since we grab Rj from the freq. domain.</span>
    <span class="c1"># --- (I&#39;m using the length of the vector before zero padding, because zero padding doesn&#39;t add energy.)</span>
    <span class="c1"># --- (This has the effect of making our final Rj estimate more conservative.)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">tie_ind_uniform</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tie_ind</span><span class="p">))</span>
    <span class="n">y_mag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">y_mag</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">y_mag</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">y_var</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">((</span><span class="n">y_mag</span> <span class="o">-</span> <span class="n">y_mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">y_mag</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">y_sigma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y_var</span><span class="p">)</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">y_mean</span> <span class="o">+</span> <span class="n">rel_thresh</span> <span class="o">*</span> <span class="n">y_sigma</span>
    <span class="n">y_per</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">y_mag</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>  <span class="c1"># Periodic components are those lying above the threshold.</span>
    <span class="n">y_rnd</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">y_mag</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># Random components are those lying below.</span>
    <span class="n">y_rnd</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y_rnd</span><span class="p">)</span>
    <span class="n">rj</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mean</span><span class="p">((</span><span class="n">y_rnd</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="n">y_rnd</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">tie_per</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">ifft</span><span class="p">(</span><span class="n">y_per</span><span class="p">))</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">valid_ix</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tie_ind</span><span class="p">))</span>  <span class="c1"># Restoring shape of vector to its original,</span>
    <span class="n">pj</span> <span class="o">=</span> <span class="n">tie_per</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span>  <span class="c1"># non-uniformly sampled state.</span>

    <span class="c1"># --- Save the spectrum, for display purposes.</span>
    <span class="n">tie_ind_spectrum</span> <span class="o">=</span> <span class="n">y_mag</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_mag</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>

    <span class="c1"># - Reassemble the jitter, excluding the Rj.</span>
    <span class="c1"># -- Here, we see why it was necessary to keep track of the non-padded elements with &#39;valid_ix&#39;:</span>
    <span class="c1"># -- It was so that we could add the average and periodic components back together,</span>
    <span class="c1"># -- maintaining correct alignment between them.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tie_per</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tie_ave</span><span class="p">):</span>
        <span class="n">tie_per</span> <span class="o">=</span> <span class="n">tie_per</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">tie_ave</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tie_per</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tie_ave</span><span class="p">):</span>
        <span class="n">tie_ave</span> <span class="o">=</span> <span class="n">tie_ave</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">tie_per</span><span class="p">)]</span>
    <span class="n">jitter_synth</span> <span class="o">=</span> <span class="n">tie_ave</span> <span class="o">+</span> <span class="n">tie_per</span>

    <span class="c1"># - Calculate the histogram of original, for comparison.</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">bin_centers</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span>

    <span class="c1"># - Calculate the histogram of everything, except Rj.</span>
    <span class="n">hist_synth</span><span class="p">,</span> <span class="n">bin_centers</span> <span class="o">=</span> <span class="n">my_hist</span><span class="p">(</span><span class="n">jitter_synth</span><span class="p">)</span>

    <span class="c1"># - Extrapolate the tails by convolving w/ complete Gaussian.</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">rj</span><span class="p">)</span>
    <span class="n">rj_pdf</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">bin_centers</span><span class="p">)</span>
    <span class="n">rj_pmf</span> <span class="o">=</span> <span class="n">rj_pdf</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rj_pdf</span><span class="p">)</span>
    <span class="n">hist_synth</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">hist_synth</span><span class="p">,</span> <span class="n">rj_pmf</span><span class="p">)</span>
    <span class="n">tail_len</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_centers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">hist_synth</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">hist_synth</span><span class="p">[:</span> <span class="n">tail_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span>
        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">hist_synth</span><span class="p">[</span><span class="n">tail_len</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">hist_synth</span><span class="p">)</span> <span class="o">-</span> <span class="n">tail_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="o">+</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">hist_synth</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">hist_synth</span><span class="p">)</span> <span class="o">-</span> <span class="n">tail_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:])]</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">jitter</span><span class="p">,</span>
        <span class="n">t_jitter</span><span class="p">,</span>
        <span class="n">isi</span><span class="p">,</span>
        <span class="n">dcd</span><span class="p">,</span>
        <span class="n">pj</span><span class="p">,</span>
        <span class="n">rj</span><span class="p">,</span>
        <span class="n">tie_ind</span><span class="p">,</span>
        <span class="n">thresh</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresh</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span>
        <span class="n">jitter_spectrum</span><span class="p">,</span>
        <span class="n">tie_ind_spectrum</span><span class="p">,</span>
        <span class="n">spectrum_freqs</span><span class="p">,</span>
        <span class="n">hist</span><span class="p">,</span>
        <span class="n">hist_synth</span><span class="p">,</span>
        <span class="n">bin_centers</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="make_uniform"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.make_uniform">[docs]</a><span class="k">def</span> <span class="nf">make_uniform</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">nbits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make the jitter vector uniformly sampled in time, by zero-filling where necessary.</span>

<span class="sd">    The trick, here, is creating a uniformly sampled input vector for the FFT operation,</span>
<span class="sd">    since the jitter samples are almost certainly not uniformly sampled.</span>
<span class="sd">    We do this by simply zero padding the missing samples.</span>

<span class="sd">    Inputs:</span>

<span class="sd">    - t      : The sample times for the &#39;jitter&#39; vector.</span>

<span class="sd">    - jitter : The input jitter samples.</span>

<span class="sd">    - ui     : The nominal unit interval.</span>

<span class="sd">    - nbits  : The desired number of unit intervals, in the time domain.</span>

<span class="sd">    Output:</span>

<span class="sd">    - y      : The uniformly sampled, zero padded jitter vector.</span>

<span class="sd">    - y_ix   : The indices where y is valid (i.e. - not zero padded).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>

    <span class="n">run_lengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">ui</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="n">valid_ix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cumsum</span><span class="p">(</span><span class="n">run_lengths</span><span class="p">))</span>
    <span class="n">valid_ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">valid_ix</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">]</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">run_lengths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_insertions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">jitter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span>  <span class="c1"># Because we use &#39;insert&#39;.</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">missing</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">run_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">jitter</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">num_insertions</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">num_insertions</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">:</span>
        <span class="n">jitter</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nbits</span><span class="p">:</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">[:</span><span class="n">nbits</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">valid_ix</span></div>


<div class="viewcode-block" id="calc_gamma"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.calc_gamma">[docs]</a><span class="k">def</span> <span class="nf">calc_gamma</span><span class="p">(</span><span class="n">R0</span><span class="p">,</span> <span class="n">w0</span><span class="p">,</span> <span class="n">Rdc</span><span class="p">,</span> <span class="n">Z0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">Theta0</span><span class="p">,</span> <span class="n">ws</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates propagation constant from cross-sectional parameters.</span>

<span class="sd">    The formula&#39;s applied are taken from Howard Johnson&#39;s &quot;Metallic Transmission Model&quot;</span>
<span class="sd">    (See &quot;High Speed Signal Propagation&quot;, Sec. 3.1.)</span>

<span class="sd">    Inputs:</span>
<span class="sd">      - R0          skin effect resistance (Ohms/m)</span>
<span class="sd">      - w0          cross-over freq.</span>
<span class="sd">      - Rdc         d.c. resistance (Ohms/m)</span>
<span class="sd">      - Z0          characteristic impedance in LC region (Ohms)</span>
<span class="sd">      - v0          propagation velocity (m/s)</span>
<span class="sd">      - Theta0      loss tangent</span>
<span class="sd">      - ws          frequency sample points vector</span>

<span class="sd">    Outputs:</span>
<span class="sd">      - gamma       frequency dependent propagation constant</span>
<span class="sd">      - Zc          frequency dependent characteristic impedance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Guard against /0.</span>
    <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0e-12</span>

    <span class="n">Rac</span> <span class="o">=</span> <span class="n">R0</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w0</span><span class="p">)</span>  <span class="c1"># AC resistance vector</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">power</span><span class="p">(</span><span class="n">Rdc</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">power</span><span class="p">(</span><span class="n">Rac</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># total resistance vector</span>
    <span class="n">L0</span> <span class="o">=</span> <span class="n">Z0</span> <span class="o">/</span> <span class="n">v0</span>  <span class="c1"># &quot;external&quot; inductance per unit length (H/m)</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">Z0</span> <span class="o">*</span> <span class="n">v0</span><span class="p">)</span>  <span class="c1"># nominal capacitance per unit length (F/m)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C0</span> <span class="o">*</span> <span class="n">power</span><span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">Theta0</span> <span class="o">/</span> <span class="n">pi</span><span class="p">))</span>  <span class="c1"># complex capacitance per unit length (F/m)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">R</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">C</span><span class="p">))</span>  <span class="c1"># propagation constant (nepers/m)</span>
    <span class="n">Zc</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">C</span><span class="p">))</span>  <span class="c1"># characteristic impedance (Ohms)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">Zc</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">calc_gamma_RLGC</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">ws</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates propagation constant from R, L, G, and C.</span>

<span class="sd">    Inputs:</span>
<span class="sd">      - R           resistance per unit length (Ohms/m)</span>
<span class="sd">      - L           inductance per unit length (Henrys/m)</span>
<span class="sd">      - G           conductance per unit length (Siemens/m)</span>
<span class="sd">      - C           capacitance per unit length (Farads/m)</span>
<span class="sd">      - ws          frequency sample points vector</span>

<span class="sd">    Outputs:</span>
<span class="sd">      - gamma       frequency dependent propagation constant</span>
<span class="sd">      - Zc          frequency dependent characteristic impedance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Guard against /0.</span>
    <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0e-12</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">R</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">C</span> <span class="o">+</span> <span class="n">G</span><span class="p">))</span>  <span class="c1"># propagation constant (nepers/m)</span>
    <span class="n">Zc</span>    <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">C</span> <span class="o">+</span> <span class="n">G</span><span class="p">))</span>  <span class="c1"># characteristic impedance (Ohms)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">Zc</span><span class="p">)</span>


<div class="viewcode-block" id="calc_G"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.calc_G">[docs]</a><span class="k">def</span> <span class="nf">calc_G</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Rs</span><span class="p">,</span> <span class="n">Cs</span><span class="p">,</span> <span class="n">Zc</span><span class="p">,</span> <span class="n">RL</span><span class="p">,</span> <span class="n">Cp</span><span class="p">,</span> <span class="n">CL</span><span class="p">,</span> <span class="n">ws</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates fully loaded transfer function of complete channel.</span>

<span class="sd">    Inputs:</span>
<span class="sd">      - H     unloaded transfer function of interconnect</span>
<span class="sd">      - Rs    source series resistance</span>
<span class="sd">      - Cs    source parallel (parasitic) capacitance</span>
<span class="sd">      - Zc    frequency dependent characteristic impedance of the interconnect</span>
<span class="sd">      - RL    load resistance (differential)</span>
<span class="sd">      - Cp    load parallel (parasitic) capacitance (single ended)</span>
<span class="sd">      - CL    load series (d.c. blocking) capacitance (single ended)</span>
<span class="sd">      - ws    frequency sample points vector</span>

<span class="sd">    Outputs:</span>
<span class="sd">      - G     frequency dependent transfer function of channel</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Guard against /0.</span>
    <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0e-12</span>

    <span class="c1"># Impedance looking back into the Tx output is a simple parallel RC network.</span>
    <span class="n">Zs</span> <span class="o">=</span> <span class="n">Rs</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">Rs</span> <span class="o">*</span> <span class="n">Cs</span><span class="p">)</span>
    <span class="c1"># Rx load impedance is 2 series, a.c.-coupling capacitors, in series w/ parallel comb. of Rterm &amp; parasitic cap.</span>
    <span class="c1"># (The two parasitic capacitances are in series.)</span>
    <span class="n">ZL</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">CL</span><span class="p">)</span> <span class="o">+</span> <span class="n">RL</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">RL</span> <span class="o">*</span> <span class="n">Cp</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Admittance into the interconnect is (Cs || Zc) / (Rs + (Cs || Zc)).</span>
    <span class="n">Cs_par_Zc</span> <span class="o">=</span> <span class="n">Zc</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">Zc</span> <span class="o">*</span> <span class="n">Cs</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Cs_par_Zc</span> <span class="o">/</span> <span class="p">(</span><span class="n">Rs</span> <span class="o">+</span> <span class="n">Cs_par_Zc</span><span class="p">)</span>
    <span class="c1"># Reflection coefficient at Rx:</span>
    <span class="n">R1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZL</span> <span class="o">-</span> <span class="n">Zc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ZL</span> <span class="o">+</span> <span class="n">Zc</span><span class="p">)</span>
    <span class="c1"># Reflection coefficient at Tx:</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Zs</span> <span class="o">-</span> <span class="n">Zc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Zs</span> <span class="o">+</span> <span class="n">Zc</span><span class="p">)</span>
    <span class="c1"># Fully loaded channel transfer function:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">R1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">R1</span> <span class="o">*</span> <span class="n">R2</span> <span class="o">*</span> <span class="n">H</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span> <span class="o">*</span> <span class="p">(((</span><span class="n">RL</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">Cp</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">RL</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">Cp</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">/</span> <span class="n">ZL</span><span class="p">)</span>  <span class="c1"># Corrected for divider action.</span>
    <span class="c1"># (i.e. - We&#39;re interested in what appears across RL.)</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="calc_eye"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.calc_eye">[docs]</a><span class="k">def</span> <span class="nf">calc_eye</span><span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">samps_per_ui</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">clock_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the &quot;eye&quot; diagram of the input signal vector.</span>

<span class="sd">    Args:</span>
<span class="sd">        ui(float): unit interval (s)</span>
<span class="sd">        samps_per_ui(int): # of samples per unit interval</span>
<span class="sd">        height(int): height of output image data array</span>
<span class="sd">        ys([float]): signal vector of interest</span>
<span class="sd">        y_max(float): max. +/- vertical extremity of plot</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        clock_times([float]): (optional) vector of clock times to use</span>
<span class="sd">            for eye centers. If not provided, just use mean</span>
<span class="sd">            zero-crossing and assume constant UI and no phase jumps.</span>
<span class="sd">            (This allows the same function to be used for eye diagram</span>
<span class="sd">            creation, for both pre and post-CDR signals.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        2D *NumPy* array: The &quot;heat map&quot; representing the eye diagram. Each grid</span>
<span class="sd">            location contains a value indicating the number of times the</span>
<span class="sd">            signal passed through that location.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># List/array necessities.</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

    <span class="c1"># Intermediate variable calculation.</span>
    <span class="n">tsamp</span> <span class="o">=</span> <span class="n">ui</span> <span class="o">/</span> <span class="n">samps_per_ui</span>

    <span class="c1"># Adjust the scaling.</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">samps_per_ui</span>
    <span class="n">y_scale</span> <span class="o">=</span> <span class="n">height</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y_max</span><span class="p">)</span>  <span class="c1"># (pixels/V)</span>
    <span class="n">y_offset</span> <span class="o">=</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># (pixels)</span>

    <span class="c1"># Generate the &quot;heat&quot; picture array.</span>
    <span class="n">img_array</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">clock_times</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">clock_time</span> <span class="ow">in</span> <span class="n">clock_times</span><span class="p">:</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">clock_time</span> <span class="o">-</span> <span class="n">ui</span>
            <span class="n">start_ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_time</span> <span class="o">/</span> <span class="n">tsamp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_ix</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">samps_per_ui</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">interp_fac</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">start_ix</span> <span class="o">*</span> <span class="n">tsamp</span><span class="p">)</span> <span class="o">//</span> <span class="n">tsamp</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">samp1</span><span class="p">,</span> <span class="n">samp2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">ys</span><span class="p">[</span><span class="n">start_ix</span> <span class="p">:</span> <span class="n">start_ix</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">samps_per_ui</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="n">start_ix</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">start_ix</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">samps_per_ui</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">samp1</span> <span class="o">+</span> <span class="p">(</span><span class="n">samp2</span> <span class="o">-</span> <span class="n">samp1</span><span class="p">)</span> <span class="o">*</span> <span class="n">interp_fac</span>
                <span class="n">img_array</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">y_scale</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">y_offset</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_ix</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">ys</span><span class="p">)))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">samps_per_ui</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">last_start_ix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">samps_per_ui</span>
        <span class="k">while</span> <span class="n">start_ix</span> <span class="o">&lt;</span> <span class="n">last_start_ix</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ys</span><span class="p">[</span><span class="n">start_ix</span> <span class="p">:</span> <span class="n">start_ix</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">samps_per_ui</span><span class="p">]:</span>
                <span class="n">img_array</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">y_scale</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">y_offset</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">start_ix</span> <span class="o">+=</span> <span class="n">samps_per_ui</span>

    <span class="k">return</span> <span class="n">img_array</span></div>

<div class="viewcode-block" id="make_ctle"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.make_ctle">[docs]</a><span class="k">def</span> <span class="nf">make_ctle</span><span class="p">(</span><span class="n">rx_bw</span><span class="p">,</span> <span class="n">peak_freq</span><span class="p">,</span> <span class="n">peak_mag</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;Passive&quot;</span><span class="p">,</span> <span class="n">dc_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the frequency response of a continuous time linear</span>
<span class="sd">    equalizer (CTLE), given the:</span>

<span class="sd">    - signal path bandwidth,</span>
<span class="sd">    - peaking specification</span>
<span class="sd">    - list of frequencies of interest, and</span>
<span class="sd">    - operational mode/offset.</span>

<span class="sd">    We use the &#39;invres()&#39; function from scipy.signal, as it suggests</span>
<span class="sd">    itself as a natural approach, given our chosen use model of having</span>
<span class="sd">    the user provide the peaking frequency and degree of peaking.</span>

<span class="sd">    That is, we define our desired frequency response using one zero</span>
<span class="sd">    and two poles, where:</span>

<span class="sd">    - The pole locations are equal to:</span>
<span class="sd">       - the signal path natural bandwidth, and</span>
<span class="sd">       - the user specified peaking frequency.</span>

<span class="sd">    - The zero location is chosen, so as to provide the desired degree</span>
<span class="sd">      of peaking.</span>

<span class="sd">    Inputs:</span>

<span class="sd">      - rx_bw        The natural (or, unequalized) signal path bandwidth (Hz).</span>

<span class="sd">      - peak_freq    The location of the desired peak in the frequency</span>
<span class="sd">                     response (Hz).</span>

<span class="sd">      - peak_mag     The desired relative magnitude of the peak (dB). (mag(H(0)) = 1)</span>

<span class="sd">      - w            The list of frequencies of interest (rads./s).</span>

<span class="sd">      - mode         The operational mode; must be one of:</span>
<span class="sd">                       - &#39;Off&#39;    : CTLE is disengaged.</span>
<span class="sd">                       - &#39;Passive&#39;: Maximum frequency response has magnitude one.</span>
<span class="sd">                       - &#39;AGC&#39;    : Automatic gain control. (Handled by calling routine.)</span>
<span class="sd">                       - &#39;Manual&#39; : D.C. offset is set manually.</span>

<span class="sd">      - dc_offset    The d.c. offset of the CTLE gain curve (dB).</span>
<span class="sd">                     (Only valid, when &#39;mode&#39; = &#39;Manual&#39;.)</span>

<span class="sd">    Outputs:</span>

<span class="sd">      - w, H         The resultant complex frequency response, at the</span>
<span class="sd">                     given frequencies.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;Off&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)))</span>

    <span class="n">p2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">rx_bw</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">peak_freq</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">/</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">peak_mag</span> <span class="o">/</span> <span class="mf">20.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p2</span> <span class="o">!=</span> <span class="n">p1</span><span class="p">:</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">invres</span><span class="p">([</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="p">[])</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;Passive&quot;</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">/=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Manual&quot;</span><span class="p">,</span> <span class="s2">&quot;AGC&quot;</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">*=</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">dc_offset</span> <span class="o">/</span> <span class="mf">20.0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Enforce d.c. offset.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;pybert_util.make_ctle(): Unrecognized value for &#39;mode&#39; parameter: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span></div>


<div class="viewcode-block" id="trim_impulse"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.trim_impulse">[docs]</a><span class="k">def</span> <span class="nf">trim_impulse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">min_len</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">1000000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim impulse response, for more useful display, by:</span>
<span class="sd">      - clipping off the tail, after 99.8% of the total power has been</span>
<span class="sd">        captured (Using 99.9% was causing problems; I don&#39;t know why.), and</span>
<span class="sd">      - setting the &quot;front porch&quot; length equal to 20% of the total length.</span>

<span class="sd">    Inputs:</span>

<span class="sd">      - g         impulse response</span>

<span class="sd">      - min_len   (optional) minimum length of returned vector</span>

<span class="sd">      - max_len   (optional) maximum length of returned vector</span>

<span class="sd">    Outputs:</span>

<span class="sd">      - g_trim    trimmed impulse response</span>

<span class="sd">      - start_ix  index of first returned sample</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Trim off potential FFT artifacts from the end and capture peak location.</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">g</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">))])</span>
    <span class="n">max_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="c1"># Capture 99.8% of the total energy.</span>
    <span class="n">Pt</span> <span class="o">=</span> <span class="mf">0.998</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">P</span> <span class="o">&lt;</span> <span class="n">Pt</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">+=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">stop_ix</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_ix</span> <span class="o">+</span> <span class="n">max_len</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">max_ix</span> <span class="o">+</span> <span class="n">min_len</span><span class="p">))</span>

    <span class="c1"># Set &quot;front porch&quot; to 20%, guarding against negative start index.</span>
    <span class="n">start_ix</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_ix</span> <span class="o">-</span> <span class="p">(</span><span class="n">stop_ix</span> <span class="o">-</span> <span class="n">max_ix</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">start_ix</span><span class="p">:</span><span class="n">stop_ix</span><span class="p">],</span> <span class="n">start_ix</span><span class="p">)</span></div>


<div class="viewcode-block" id="import_channel"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.import_channel">[docs]</a><span class="k">def</span> <span class="nf">import_channel</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">,</span> <span class="n">padded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">windowed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read in a channel file.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename(str): Name of file from which to import channel description.</span>
<span class="sd">        sample_per(float): Sample period of signal vector (s).</span>
<span class="sd">        padded(Bool): (Optional) Zero pad s4p data, such that fmax &gt;= 1/(2*sample_per)? (Default = False)</span>
<span class="sd">        windowed(Bool): (Optional) Window s4p data, before converting to time domain? (Default = False)</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: Imported channel impulse, or step, response.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">extension</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;s4p&quot;</span><span class="p">,</span> <span class="s2">&quot;S4P&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">import_freq</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">,</span> <span class="n">padded</span><span class="o">=</span><span class="n">padded</span><span class="p">,</span> <span class="n">windowed</span><span class="o">=</span><span class="n">windowed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">import_time</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp_time"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.interp_time">[docs]</a><span class="k">def</span> <span class="nf">interp_time</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample time domain data, using linear interpolation.</span>

<span class="sd">    Args:</span>
<span class="sd">        ts([float]): Original time values.</span>
<span class="sd">        xs([float]): Original signal values.</span>
<span class="sd">        sample_per(float): System sample period.</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: Resampled waveform.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmax</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">tmax</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">sample_per</span>

    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="import_time"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.import_time">[docs]</a><span class="k">def</span> <span class="nf">import_time</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read in a time domain waveform file, resampling as</span>
<span class="sd">    appropriate, via linear interpolation.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename(str): Name of waveform file to read in.</span>
<span class="sd">        sample_per(float): New sample interval</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: Resampled waveform.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rU&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="p">[</span><span class="n">_f</span> <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[, ;:]+&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span> <span class="k">if</span> <span class="n">_f</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">interp_time</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">)</span></div>


<div class="viewcode-block" id="sdd_21"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.sdd_21">[docs]</a><span class="k">def</span> <span class="nf">sdd_21</span><span class="p">(</span><span class="n">ntwk</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a 4-port single-ended network, return its differential throughput.</span>

<span class="sd">    Args:</span>
<span class="sd">        ntwk(skrf.Network): 4-port single ended network.</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: Sdd[2,1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">real</span><span class="p">(</span><span class="n">ntwk</span><span class="o">.</span><span class="n">s21</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>  <span class="c1"># 1 ==&gt; 3 port numbering?</span>
        <span class="n">ntwk</span><span class="o">.</span><span class="n">renumber</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntwk</span><span class="o">.</span><span class="n">s21</span> <span class="o">-</span> <span class="n">ntwk</span><span class="o">.</span><span class="n">s23</span> <span class="o">+</span> <span class="n">ntwk</span><span class="o">.</span><span class="n">s43</span> <span class="o">-</span> <span class="n">ntwk</span><span class="o">.</span><span class="n">s41</span><span class="p">)</span></div>


<div class="viewcode-block" id="import_freq"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.import_freq">[docs]</a><span class="k">def</span> <span class="nf">import_freq</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">,</span> <span class="n">padded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">windowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">f_step</span><span class="o">=</span><span class="mf">10e6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read in a single ended 4-port Touchstone file, and extract the</span>
<span class="sd">    differential throughput step response, resampling as</span>
<span class="sd">    appropriate, via linear interpolation.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename(str): Name of Touchstone file to read in.</span>
<span class="sd">        sample_per(float): New sample interval</span>
<span class="sd">        padded(Bool): (Optional) Zero pad s4p data, such that fmax &gt;= 1/(2*sample_per)? (Default = False)</span>
<span class="sd">        windowed(Bool): (Optional) Window s4p data, before converting to time domain? (Default = False)</span>

<span class="sd">    Returns:</span>
<span class="sd">        [float]: Resampled step response waveform.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ntwk</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="c1"># Form frequency vector.</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ntwk</span><span class="o">.</span><span class="n">f</span>
    <span class="n">fmin</span> <span class="o">=</span> <span class="n">f_step</span>
    <span class="n">fmax</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span> <span class="o">+</span> <span class="n">fmin</span><span class="p">,</span> <span class="n">fmin</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">Frequency</span><span class="o">.</span><span class="n">from_f</span><span class="p">(</span><span class="n">f</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>  <span class="c1"># skrf.Frequency.from_f() expects its argument to be in units of GHz.</span>

    <span class="c1"># Form impulse response from frequency response.</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">sdd_21</span><span class="p">(</span><span class="n">ntwk</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate_from_f</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Presume d.c. value = 1.</span>
    <span class="k">if</span> <span class="n">windowed</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">))[</span><span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="p">:]</span>
        <span class="n">H</span> <span class="o">*=</span> <span class="n">window</span>
    <span class="k">if</span> <span class="n">padded</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">fmin</span> <span class="o">*</span> <span class="n">sample_per</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fmax</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sample_per</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>  <span class="c1"># Equivalent to assuming that step response settles at 1.</span>

    <span class="c1"># Form step response from impulse response.</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="c1"># Form time vector.</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">fmax</span><span class="p">)</span>  <span class="c1"># Sampling interval = 1 / (2 fNyquist).</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="o">*</span> <span class="n">t0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))])</span>

    <span class="k">return</span> <span class="n">interp_time</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">sample_per</span><span class="p">)</span></div>


<div class="viewcode-block" id="lfsr_bits"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.lfsr_bits">[docs]</a><span class="k">def</span> <span class="nf">lfsr_bits</span><span class="p">(</span><span class="n">taps</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of tap indices and a seed, generate a PRBS.</span>

<span class="sd">    Args:</span>
<span class="sd">        taps([int]): The set of fed back taps.</span>
<span class="sd">                     (Largest determines order of generator.)</span>
<span class="sd">        seed(int): The initial value of the shift register.</span>

<span class="sd">    Returns:</span>
<span class="sd">        generator: A PRBS generator object with a next() method, for retrieving</span>
<span class="sd">            the next bit in the sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">num_taps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">taps</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">num_taps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">xor_res</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">x</span> <span class="o">^</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">tap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="k">for</span> <span class="n">tap</span> <span class="ow">in</span> <span class="n">taps</span><span class="p">])</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>  <span class="c1"># Just to keep &#39;val&#39; from growing without bound.</span>
        <span class="k">if</span> <span class="n">xor_res</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="safe_log10"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.safe_log10">[docs]</a><span class="k">def</span> <span class="nf">safe_log10</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guards against pesky &#39;Divide by 0&#39; error messages.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0e-20</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mf">1.0e-20</span>

    <span class="k">return</span> <span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="pulse_center"><a class="viewcode-back" href="../../modules.html#pybert.pybert_util.pulse_center">[docs]</a><span class="k">def</span> <span class="nf">pulse_center</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nspui</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the center of the pulse response, using the &quot;Hula Hoop&quot;</span>
<span class="sd">    algorithm (See SiSoft/Tellian&#39;s DesignCon 2016 paper.)</span>

<span class="sd">    Args:</span>
<span class="sd">        p([Float]): The single bit pulse response.</span>
<span class="sd">        nspui(Int): The number of vector elements per unit interval.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (Int, float): The estimated index at which the clock will</span>
<span class="sd">            sample the main lobe, and the vertical threshold at which</span>
<span class="sd">            the main lobe is UI wide.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">div</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">p_max</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">p_max</span> <span class="o">/</span> <span class="n">div</span>
    <span class="n">main_lobe_ixs</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">main_lobe_ixs</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c1"># Sometimes, the optimizer really whacks out.</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Flag this, by returning an impossible index.</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">main_lobe_ixs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">main_lobe_ixs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nspui</span>
    <span class="k">while</span> <span class="n">err</span> <span class="ow">and</span> <span class="n">div</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">:</span>
        <span class="n">div</span> <span class="o">*=</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">thresh</span> <span class="o">+=</span> <span class="n">p_max</span> <span class="o">/</span> <span class="n">div</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh</span> <span class="o">-=</span> <span class="n">p_max</span> <span class="o">/</span> <span class="n">div</span>
        <span class="n">main_lobe_ixs</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">main_lobe_ixs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">main_lobe_ixs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nspui</span>

    <span class="n">clock_pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mean</span><span class="p">([</span><span class="n">main_lobe_ixs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main_lobe_ixs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">clock_pos</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">submodules</span><span class="p">(</span><span class="n">package</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find all sub-modules of a package.&quot;&quot;&quot;</span>
    <span class="n">rst</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">imp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">pkgutil</span><span class="o">.</span><span class="n">iter_modules</span><span class="p">(</span><span class="n">package</span><span class="o">.</span><span class="n">__path__</span><span class="p">):</span>
        <span class="n">fullModuleName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">package</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">fullModuleName</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="n">package</span><span class="o">.</span><span class="n">__path__</span><span class="p">)</span>
        <span class="n">rst</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod</span>

    <span class="k">return</span> <span class="n">rst</span> 
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">PyBERT</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">General description of <em>pybert</em> package.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Modules in <em>pybert</em> package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, David Banas.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>