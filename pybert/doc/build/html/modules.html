<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modules in pybert package &mdash; PyBERT Developer Guide 2.0.5 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyBERT Developer Guide 2.0.5 documentation" href="index.html" />
    <link rel="prev" title="General description of pybert package." href="intro.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro.html" title="General description of pybert package."
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyBERT Developer Guide 2.0.5 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="modules-in-pybert-package">
<h1>Modules in <em>pybert</em> package<a class="headerlink" href="#modules-in-pybert-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-pybert.pybert">
<span id="pybert-main-pybert-class-definition-as-well-as-some-helper-classes"></span><h2>pybert - Main <em>PyBERT</em> class definition, as well as some helper classes.<a class="headerlink" href="#module-pybert.pybert" title="Permalink to this headline">¶</a></h2>
<p>Bit error rate tester (BERT) simulator, written in Python.</p>
<p>Original Author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original Date:   17 June 2014</p>
<p>Testing by: Mark Marlett &lt;<a class="reference external" href="mailto:mark&#46;marlett&#37;&#52;&#48;gmail&#46;com">mark<span>&#46;</span>marlett<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>This Python script provides a GUI interface to a BERT simulator, which
can be used to explore the concepts of serial communication link design.</p>
<p>Copyright (c) 2014 by David Banas; All rights reserved World wide.</p>
<dl class="class">
<dt id="pybert.pybert.PyBERT">
<em class="property">class </em><code class="descclassname">pybert.pybert.</code><code class="descname">PyBERT</code><span class="sig-paren">(</span><em>run_simulation=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert.html#PyBERT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert.PyBERT" title="Permalink to this definition">¶</a></dt>
<dd><p>A serial communication link bit error rate tester (BERT) simulator with a GUI interface.</p>
<p>Useful for exploring the concepts of serial communication link design.</p>
<p>Initial plot setup occurs here.</p>
<p>In order to populate the data structure we need to
construct the plots, we must run the simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>run_simulation</strong> (<em>Bool</em>) &#8211; If true, run the simulation, as part
of class initialization. This is provided as an argument
for the sake of larger applications, which may be
importing PyBERT for its attributes and methods, and may
not want to run the full simulation. (Optional;
default = True)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pybert.pybert.PyBERT.calc_chnl_h">
<code class="descname">calc_chnl_h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert.html#PyBERT.calc_chnl_h"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert.PyBERT.calc_chnl_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the channel impulse response.</p>
<dl class="docutils">
<dt>Also sets, in &#8216;self&#8217;:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>chnl_dly:</dt>
<dd><p class="first last">group delay of channel</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>start_ix:</dt>
<dd><p class="first last">first element of trimmed response</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>t_ns_chnl:</dt>
<dd><p class="first last">the x-values, in ns, for plotting &#8216;chnl_h&#8217;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>chnl_H:</dt>
<dd><p class="first last">channel frequency response</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>chnl_s:</dt>
<dd><p class="first last">channel step response</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>chnl_p:</dt>
<dd><p class="first last">channel pulse response</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pybert.pybert.TxOptThread">
<em class="property">class </em><code class="descclassname">pybert.pybert.</code><code class="descname">TxOptThread</code><span class="sig-paren">(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert.html#TxOptThread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert.TxOptThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to run Tx tap weight optimization in its own thread, in order to preserve GUI responsiveness.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form &#8220;Thread-N&#8221; where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.__init__()) before doing anything
else to the thread.</p>
</dd></dl>

<dl class="class">
<dt id="pybert.pybert.RxOptThread">
<em class="property">class </em><code class="descclassname">pybert.pybert.</code><code class="descname">RxOptThread</code><span class="sig-paren">(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert.html#RxOptThread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert.RxOptThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to run Rx tap weight optimization in its own thread, in order to preserve GUI responsiveness.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form &#8220;Thread-N&#8221; where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.__init__()) before doing anything
else to the thread.</p>
</dd></dl>

<dl class="class">
<dt id="pybert.pybert.CoOptThread">
<em class="property">class </em><code class="descclassname">pybert.pybert.</code><code class="descname">CoOptThread</code><span class="sig-paren">(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert.html#CoOptThread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert.CoOptThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to run co-optimization in its own thread, in order to preserve GUI responsiveness.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form &#8220;Thread-N&#8221; where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.__init__()) before doing anything
else to the thread.</p>
</dd></dl>

<dl class="class">
<dt id="pybert.pybert.TxTapTuner">
<em class="property">class </em><code class="descclassname">pybert.pybert.</code><code class="descname">TxTapTuner</code><span class="sig-paren">(</span><em>name='(noname)'</em>, <em>enabled=False</em>, <em>min_val=0.0</em>, <em>max_val=0.0</em>, <em>value=0.0</em>, <em>steps=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert.html#TxTapTuner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert.TxTapTuner" title="Permalink to this definition">¶</a></dt>
<dd><p>Object used to populate the rows of the Tx FFE tap tuning table.</p>
<p>Allows user to define properties, at instantiation.</p>
</dd></dl>

</div>
<div class="section" id="module-pybert.pybert_cntrl">
<span id="pybert-cntrl-model-control-logic"></span><h2>pybert_cntrl - Model control logic.<a class="headerlink" href="#module-pybert.pybert_cntrl" title="Permalink to this headline">¶</a></h2>
<p>Default controller definition for PyBERT class.</p>
<p>Original author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original date:   August 24, 2014 (Copied from <a href="#id1"><span class="problematic" id="id2">`</span></a>pybert.py&#8217;, as part of a major code cleanup.)</p>
<p>Copyright (c) 2014 David Banas; all rights reserved World wide.</p>
<dl class="function">
<dt id="pybert.pybert_cntrl.my_run_sweeps">
<code class="descclassname">pybert.pybert_cntrl.</code><code class="descname">my_run_sweeps</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_cntrl.html#my_run_sweeps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_cntrl.my_run_sweeps" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the simulation sweeps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>self</strong> (<a class="reference internal" href="#pybert.pybert.PyBERT" title="pybert.pybert.PyBERT"><em>PyBERT</em></a>) &#8211; Reference to an instance of the <em>PyBERT</em> class.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_cntrl.my_run_simulation">
<code class="descclassname">pybert.pybert_cntrl.</code><code class="descname">my_run_simulation</code><span class="sig-paren">(</span><em>self</em>, <em>initial_run=False</em>, <em>update_plots=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_cntrl.html#my_run_simulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_cntrl.my_run_simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>self</strong> (<a class="reference internal" href="#pybert.pybert.PyBERT" title="pybert.pybert.PyBERT"><em>PyBERT</em></a>) &#8211; Reference to an instance of the <em>PyBERT</em> class.</li>
<li><strong>initial_run</strong> (<em>Bool</em>) &#8211; If True, don&#8217;t update the eye diagrams, since
they haven&#8217;t been created, yet. (Optional; default = False.)</li>
<li><strong>update_plots</strong> (<em>Bool</em>) &#8211; If True, update the plots, after simulation
completes. This option can be used by larger scripts, which
import <em>pybert</em>, in order to avoid graphical back-end
conflicts and speed up this function&#8217;s execution time.
(Optional; default = True.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_cntrl.update_results">
<code class="descclassname">pybert.pybert_cntrl.</code><code class="descname">update_results</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_cntrl.html#update_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_cntrl.update_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates all plot data used by GUI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>self</strong> (<a class="reference internal" href="#pybert.pybert.PyBERT" title="pybert.pybert.PyBERT"><em>PyBERT</em></a>) &#8211; Reference to an instance of the <em>PyBERT</em> class.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_cntrl.update_eyes">
<code class="descclassname">pybert.pybert_cntrl.</code><code class="descname">update_eyes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_cntrl.html#update_eyes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_cntrl.update_eyes" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the heat plots representing the eye diagrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>self</strong> (<a class="reference internal" href="#pybert.pybert.PyBERT" title="pybert.pybert.PyBERT"><em>PyBERT</em></a>) &#8211; Reference to an instance of the <em>PyBERT</em> class.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pybert.pybert_view">
<span id="pybert-view-main-gui-window-layout-definition"></span><h2>pybert_view - Main GUI window layout definition.<a class="headerlink" href="#module-pybert.pybert_view" title="Permalink to this headline">¶</a></h2>
<p>Default view definition for PyBERT class.</p>
<p>Original author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original date:   August 24, 2014 (Copied from <a href="#id3"><span class="problematic" id="id4">`</span></a>pybert.py&#8217;, as part of a major code cleanup.)</p>
<p>Copyright (c) 2014 David Banas; all rights reserved World wide.</p>
<dl class="class">
<dt id="pybert.pybert_view.MyHandler">
<em class="property">class </em><code class="descclassname">pybert.pybert_view.</code><code class="descname">MyHandler</code><a class="reference internal" href="_modules/pybert/pybert_view.html#MyHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_view.MyHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>This handler is instantiated by the View and handles user button clicks.</p>
</dd></dl>

<dl class="class">
<dt id="pybert.pybert_view.RunSimThread">
<em class="property">class </em><code class="descclassname">pybert.pybert_view.</code><code class="descname">RunSimThread</code><span class="sig-paren">(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_view.html#RunSimThread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_view.RunSimThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to run the simulation in its own thread, in order to preserve GUI responsiveness.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form &#8220;Thread-N&#8221; where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.__init__()) before doing anything
else to the thread.</p>
</dd></dl>

</div>
<div class="section" id="module-pybert.pybert_util">
<span id="pybert-util-various-utilities-used-by-other-modules"></span><h2>pybert_util - Various utilities used by other modules.<a class="headerlink" href="#module-pybert.pybert_util" title="Permalink to this headline">¶</a></h2>
<p>General purpose utilities for PyBERT.</p>
<p>Original author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original date:   September 27, 2014 (Copied from <a href="#id5"><span class="problematic" id="id6">`</span></a>pybert_cntrl.py&#8217;.)</p>
<p>Copyright (c) 2014 David Banas; all rights reserved World wide.</p>
<dl class="function">
<dt id="pybert.pybert_util.moving_average">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">moving_average</code><span class="sig-paren">(</span><em>a</em>, <em>n=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#moving_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.moving_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a sliding average over the input vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> (<em>[float]</em>) &#8211; Input vector to be averaged.</li>
<li><strong>n</strong> (<em>int</em>) &#8211; Width of averaging window, in vector samples. (Optional;
default = 3.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns: the moving average of the input vector, leaving the input</dt>
<dd>vector unchanged.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.find_crossing_times">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">find_crossing_times</code><span class="sig-paren">(</span><em>t</em>, <em>x</em>, <em>min_delay=0.0</em>, <em>rising_first=True</em>, <em>min_init_dev=0.1</em>, <em>thresh=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#find_crossing_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.find_crossing_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the threshold crossing times of the input signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> (<em>[float]</em>) &#8211; Vector of sample times. Intervals do NOT need to be
uniform.</li>
<li><strong>x</strong> (<em>[float]</em>) &#8211; Sampled input vector.</li>
<li><strong>min_delay</strong> (<em>float</em>) &#8211; Minimum delay required, before allowing
crossings. (Helps avoid false crossings at beginning of
signal.) (Optional; default = 0.)</li>
<li><strong>rising_first</strong> (<em>bool</em>) &#8211; When True, start with the first rising edge
found. (Optional; default = True.) When this option is True,
the first rising edge crossing is the first crossing returned.
This is the desired behavior for PyBERT, because we always
initialize the bit stream with [0, 0, 1, 1], in order to
provide a known synchronization point for jitter analysis.</li>
<li><strong>min_init_dev</strong> (<em>float</em>) &#8211; The minimum initial deviation from zero,
which must be detected, before searching for crossings.
Normalized to maximum input signal magnitude.
(Optional; default = 0.1.)</li>
<li><strong>thresh</strong> (<em>float</em>) &#8211; Vertical crossing threshold.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: an array of signal threshold crossing times.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.find_crossings">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">find_crossings</code><span class="sig-paren">(</span><em>t</em>, <em>x</em>, <em>amplitude</em>, <em>min_delay=0.0</em>, <em>rising_first=True</em>, <em>min_init_dev=0.1</em>, <em>mod_type=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#find_crossings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.find_crossings" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the crossing times in a signal, according to the modulation type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> (<em>[float]</em>) &#8211; The times associated with each signal sample.</li>
<li><strong>x</strong> (<em>[float]</em>) &#8211; The signal samples.</li>
<li><strong>amplitude</strong> (<em>float</em>) &#8211; The nominal signal amplitude. (Used for
determining thresholds, in the case of some modulation
types.)</li>
<li><strong>min_delay</strong> (<em>float</em>) &#8211; The earliest possible sample time we want
returned. (Optional; default = 0.)</li>
<li><strong>rising_first</strong> (<em>bool</em>) &#8211; When True, start with the first rising edge
found. When this option is True, the first rising edge
crossing is the first crossing returned. This is the desired
behavior for PyBERT, because we always initialize the bit
stream with [0, 1, 1], in order to provide a known
synchronization point for jitter analysis.
(Optional; default = True.)</li>
<li><strong>min_init_dev</strong> (<em>float</em>) &#8211; The minimum initial deviation from zero,
which must be detected, before searching for crossings.
Normalized to maximum input signal magnitude.
(Optional; default = 0.1.)</li>
<li><strong>mod_type</strong> (<em>int</em>) &#8211; The modulation type. Allowed values are:
{0: NRZ, 1: Duo-binary, 2: PAM-4}
(Optional; default = 0.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: The signal threshold crossing times.</p>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_jitter">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_jitter</code><span class="sig-paren">(</span><em>ui</em>, <em>nui</em>, <em>pattern_len</em>, <em>ideal_xings</em>, <em>actual_xings</em>, <em>rel_thresh=6</em>, <em>num_bins=99</em>, <em>zero_mean=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_jitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the jitter in a set of actual zero crossings, given the ideal crossings and unit interval.</p>
<p>Inputs:</p>
<blockquote>
<div><ul class="simple">
<li>ui               : The nominal unit interval.</li>
<li>nui              : The number of unit intervals spanned by the input signal.</li>
<li>pattern_len      : The number of unit intervals, before input symbol stream repeats.</li>
<li>ideal_xings      : The ideal zero crossing locations of the edges.</li>
<li>actual_xings     : The actual zero crossing locations of the edges.</li>
<li>rel_thresh       : (optional) The threshold for determining periodic jitter spectral components (sigma).</li>
<li>num_bins         : (optional) The number of bins to use, when forming histograms.</li>
<li>zero_mean        : (optional) Force the mean jitter to zero, when True.</li>
</ul>
</div></blockquote>
<p>Outputs:</p>
<blockquote>
<div><ul class="simple">
<li>jitter   : The total jitter.</li>
<li>t_jitter : The times (taken from &#8216;ideal_xings&#8217;) corresponding to the returned jitter values.</li>
<li>isi      : The peak to peak jitter due to intersymbol interference.</li>
<li>dcd      : The peak to peak jitter due to duty cycle distortion.</li>
<li>pj       : The peak to peak jitter due to uncorrelated periodic sources.</li>
<li>rj       : The standard deviation of the jitter due to uncorrelated unbounded random sources.</li>
<li>tie_ind  : The data independent jitter.</li>
<li>thresh   : Threshold for determining periodic components.</li>
<li>jitter_spectrum  : The spectral magnitude of the total jitter.</li>
<li>tie_ind_spectrum : The spectral magnitude of the data independent jitter.</li>
<li>spectrum_freqs   : The frequencies corresponding to the spectrum components.</li>
<li>hist        : The histogram of the actual jitter.</li>
<li>hist_synth  : The histogram of the extrapolated jitter.</li>
<li>bin_centers : The bin center values for both histograms.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.make_uniform">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">make_uniform</code><span class="sig-paren">(</span><em>t</em>, <em>jitter</em>, <em>ui</em>, <em>nbits</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#make_uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.make_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the jitter vector uniformly sampled in time, by zero-filling where necessary.</p>
<p>The trick, here, is creating a uniformly sampled input vector for the FFT operation,
since the jitter samples are almost certainly not uniformly sampled.
We do this by simply zero padding the missing samples.</p>
<p>Inputs:</p>
<ul class="simple">
<li>t      : The sample times for the &#8216;jitter&#8217; vector.</li>
<li>jitter : The input jitter samples.</li>
<li>ui     : The nominal unit interval.</li>
<li>nbits  : The desired number of unit intervals, in the time domain.</li>
</ul>
<p>Output:</p>
<ul class="simple">
<li>y      : The uniformly sampled, zero padded jitter vector.</li>
<li>y_ix   : The indices where y is valid (i.e. - not zero padded).</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_gamma">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_gamma</code><span class="sig-paren">(</span><em>R0</em>, <em>w0</em>, <em>Rdc</em>, <em>Z0</em>, <em>v0</em>, <em>Theta0</em>, <em>ws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_gamma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates propagation constant from cross-sectional parameters.</p>
<p>The formula&#8217;s applied are taken from Howard Johnson&#8217;s &#8220;Metallic Transmission Model&#8221;
(See &#8220;High Speed Signal Propagation&#8221;, Sec. 3.1.)</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><ul class="first last simple">
<li>R0          skin effect resistance (Ohms/m)</li>
<li>w0          cross-over freq.</li>
<li>Rdc         d.c. resistance (Ohms/m)</li>
<li>Z0          characteristic impedance in LC region (Ohms)</li>
<li>v0          propagation velocity (m/s)</li>
<li>Theta0      loss tangent</li>
<li>ws          frequency sample points vector</li>
</ul>
</dd>
<dt>Outputs:</dt>
<dd><ul class="first last simple">
<li>gamma       frequency dependent propagation constant</li>
<li>Zc          frequency dependent characteristic impedance</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_G">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_G</code><span class="sig-paren">(</span><em>H</em>, <em>Rs</em>, <em>Cs</em>, <em>Zc</em>, <em>RL</em>, <em>Cp</em>, <em>CL</em>, <em>ws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_G"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_G" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates fully loaded transfer function of complete channel.</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><ul class="first last simple">
<li>H     unloaded transfer function of interconnect</li>
<li>Rs    source series resistance</li>
<li>Cs    source parallel (parasitic) capacitance</li>
<li>Zc    frequency dependent characteristic impedance of the interconnect</li>
<li>RL    load resistance (differential)</li>
<li>Cp    load parallel (parasitic) capacitance (single ended)</li>
<li>CL    load series (d.c. blocking) capacitance (single ended)</li>
<li>ws    frequency sample points vector</li>
</ul>
</dd>
<dt>Outputs:</dt>
<dd><ul class="first last simple">
<li>G     frequency dependent transfer function of channel</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.calc_eye">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">calc_eye</code><span class="sig-paren">(</span><em>ui</em>, <em>samps_per_ui</em>, <em>height</em>, <em>ys</em>, <em>y_max</em>, <em>clock_times=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#calc_eye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.calc_eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the &#8220;eye&#8221; diagram of the input signal vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ui</strong> (<em>float</em>) &#8211; unit interval (s)</li>
<li><strong>samps_per_ui</strong> (<em>int</em>) &#8211; # of samples per unit interval</li>
<li><strong>height</strong> (<em>int</em>) &#8211; height of output image data array</li>
<li><strong>ys</strong> (<em>[float]</em>) &#8211; signal vector of interest</li>
<li><strong>y_max</strong> (<em>float</em>) &#8211; max. +/- vertical extremity of plot</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last"><strong>clock_times</strong> (<em>[float]</em>) &#8211;
(optional) vector of clock times to use
for eye centers. If not provided, just use mean
zero-crossing and assume constant UI and no phase jumps.
(This allows the same function to be used for eye diagram
creation, for both pre and post-CDR signals.)</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns: The &#8220;heat map&#8221; representing the eye diagram. Each grid</dt>
<dd>location contains a value indicating the number of times the
signal passed through that location.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.make_ctle">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">make_ctle</code><span class="sig-paren">(</span><em>rx_bw</em>, <em>peak_freq</em>, <em>peak_mag</em>, <em>w</em>, <em>mode='Passive'</em>, <em>dc_offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#make_ctle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.make_ctle" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the frequency response of a continuous time linear
equalizer (CTLE), given the:</p>
<ul class="simple">
<li>signal path bandwidth,</li>
<li>peaking specification</li>
<li>list of frequencies of interest, and</li>
<li>operational mode/offset.</li>
</ul>
<p>We use the &#8216;invres()&#8217; function from scipy.signal, as it suggests
itself as a natural approach, given our chosen use model of having
the user provide the peaking frequency and degree of peaking.</p>
<p>That is, we define our desired frequency response using one zero
and two poles, where:</p>
<ul>
<li><dl class="first docutils">
<dt>The pole locations are equal to:</dt>
<dd><ul class="first last simple">
<li>the signal path natural bandwidth, and</li>
<li>the user specified peaking frequency.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">The zero location is chosen, so as to provide the desired degree
of peaking.</p>
</li>
</ul>
<p>Inputs:</p>
<blockquote>
<div><ul>
<li><p class="first">rx_bw        The natural (or, unequalized) signal path bandwidth (Hz).</p>
</li>
<li><dl class="first docutils">
<dt>peak_freq    The location of the desired peak in the frequency</dt>
<dd><p class="first last">response (Hz).</p>
</dd>
</dl>
</li>
<li><p class="first">peak_mag     The desired relative magnitude of the peak (dB). (mag(H(0)) = 1)</p>
</li>
<li><p class="first">w            The list of frequencies of interest (rads./s).</p>
</li>
<li><dl class="first docutils">
<dt>mode         The operational mode; must be one of:</dt>
<dd><ul class="first last simple">
<li>&#8216;Off&#8217;    : CTLE is disengaged.</li>
<li>&#8216;Passive&#8217;: Maximum frequency response has magnitude one.</li>
<li>&#8216;AGC&#8217;    : Automatic gain control. (Handled by calling routine.)</li>
<li>&#8216;Manual&#8217; : D.C. offset is set manually.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dc_offset    The d.c. offset of the CTLE gain curve (dB).</dt>
<dd><p class="first last">(Only valid, when &#8216;mode&#8217; = &#8216;Manual&#8217;.)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Outputs:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>w, H         The resultant complex frequency response, at the</dt>
<dd><p class="first last">given frequencies.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.trim_impulse">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">trim_impulse</code><span class="sig-paren">(</span><em>g</em>, <em>Ts=0</em>, <em>chnl_dly=0</em>, <em>min_len=0</em>, <em>max_len=1000000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#trim_impulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.trim_impulse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Trim impulse response, for more useful display, by:</dt>
<dd><ul class="first last simple">
<li>eliminating 90% of the overall delay from the beginning, and</li>
<li>clipping off the tail, after 99.8% of the total power has been captured.
(Using 99.9% was causing problems; I don&#8217;t know why.)</li>
</ul>
</dd>
</dl>
<p>Inputs:</p>
<blockquote>
<div><ul class="simple">
<li>g         impulse response</li>
<li>Ts        (optional) sample interval (same units as &#8216;chnl_dly&#8217;)</li>
<li>chnl_dly  (optional) channel delay</li>
<li>min_len   (optional) minimum length of returned vector</li>
<li>max_len   (optional) maximum length of returned vector</li>
</ul>
</div></blockquote>
<p>Outputs:</p>
<blockquote>
<div><ul class="simple">
<li>g_trim    trimmed impulse response</li>
<li>start_ix  index of first returned sample</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pybert.pybert_util.import_qucs_csv">
<code class="descclassname">pybert.pybert_util.</code><code class="descname">import_qucs_csv</code><span class="sig-paren">(</span><em>filename</em>, <em>sample_per</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/pybert_util.html#import_qucs_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.pybert_util.import_qucs_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in a CSV waveform file exported by QUCS, resampling as
appropriate, via linear interpolation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; Name of waveform file to read in.</li>
<li><strong>sample_per</strong> (<em>float</em>) &#8211; New sample interval</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: Resampled waveform.</p>
</dd></dl>

</div>
<div class="section" id="module-pybert.pybert_plot">
<span id="pybert-plot-plot-definitions-for-the-pybert-gui"></span><h2>pybert_plot - Plot definitions for the <em>PyBERT</em> GUI.<a class="headerlink" href="#module-pybert.pybert_plot" title="Permalink to this headline">¶</a></h2>
<p>Plot definitions for PyBERT class.</p>
<p>Original author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original date:   February 21, 2015 (Copied from <a href="#id7"><span class="problematic" id="id8">`</span></a>pybert.py&#8217;, as part of a major code cleanup.)</p>
<p>Copyright (c) 2015 David Banas; all rights reserved World wide.</p>
</div>
<div class="section" id="module-pybert.pybert_help">
<span id="pybert-help-contents-of-the-help-tab-of-the-pybert-gui"></span><h2>pybert_help - Contents of the <em>Help</em> tab of the <em>PyBERT</em> GUI.<a class="headerlink" href="#module-pybert.pybert_help" title="Permalink to this headline">¶</a></h2>
<p>User instructions for PyBERT class.</p>
<p>Original author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original date:   April 15, 2015 (Copied from <a href="#id9"><span class="problematic" id="id10">`</span></a>pybert.py&#8217;.)</p>
<p>Copyright (c) 2015 David Banas; all rights reserved World wide.</p>
</div>
<div class="section" id="module-pybert.dfe">
<span id="dfe-dfe-behavioral-model"></span><h2>dfe - DFE behavioral model.<a class="headerlink" href="#module-pybert.dfe" title="Permalink to this headline">¶</a></h2>
<p>Behavioral model of a decision feedback equalizer (DFE).</p>
<p>Original Author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original Date:   17 June 2014</p>
<p>This Python script provides a behavioral model of a decision feedback
equalizer (DFE). The class defined, here, is intended for integration
into the larger <em>PyBERT</em> framework.</p>
<p>Copyright (c) 2014 by David Banas; All rights reserved World wide.</p>
<dl class="class">
<dt id="pybert.dfe.LfilterSS">
<em class="property">class </em><code class="descclassname">pybert.dfe.</code><code class="descname">LfilterSS</code><span class="sig-paren">(</span><em>b</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#LfilterSS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.LfilterSS" title="Permalink to this definition">¶</a></dt>
<dd><p>A single steppable version of scipy.signal.lfilter().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>b</strong> (<em>[float]</em>) &#8211; Coefficients of the numerator of the rational transfer function.</li>
<li><strong>a</strong> (<em>[float]</em>) &#8211; Coefficients of the denominator of the rational transfer function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pybert.dfe.LfilterSS.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#LfilterSS.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.LfilterSS.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step the filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>float</em>) &#8211; Next input value.</td>
</tr>
</tbody>
</table>
<p>Returns: Next output value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pybert.dfe.DFE">
<em class="property">class </em><code class="descclassname">pybert.dfe.</code><code class="descname">DFE</code><span class="sig-paren">(</span><em>n_taps</em>, <em>gain</em>, <em>delta_t</em>, <em>alpha</em>, <em>ui</em>, <em>n_spb</em>, <em>decision_scaler</em>, <em>mod_type=0</em>, <em>bandwidth=100000000000.0</em>, <em>n_ave=10</em>, <em>n_lock_ave=500</em>, <em>rel_lock_tol=0.01</em>, <em>lock_sustain=500</em>, <em>ideal=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE" title="Permalink to this definition">¶</a></dt>
<dd><p>Behavioral model of a decision feedback equalizer (DFE).</p>
<p>Inputs:</p>
<blockquote>
<div><p>Required:</p>
<ul>
<li><p class="first">n_taps           # of taps in adaptive filter</p>
</li>
<li><p class="first">gain             adaptive filter tap weight correction gain</p>
</li>
<li><p class="first">delta_t          CDR proportional branch constant (ps)</p>
</li>
<li><p class="first">alpha            CDR integral branch constant (normalized to delta_t)</p>
</li>
<li><p class="first">ui               nominal unit interval (ps)</p>
</li>
<li><p class="first">n_spb            # of samples per unit interval</p>
</li>
<li><dl class="first docutils">
<dt>decision_scaler  multiplicative constant applied to the result of</dt>
<dd><p class="first last">the sign function, when making a &#8220;1 vs. 0&#8221; decision.
Sets the target magnitude for the DFE.</p>
</dd>
</dl>
</li>
</ul>
<p>Optional:</p>
<ul>
<li><dl class="first docutils">
<dt>mod_type         The modulation type:</dt>
<dd><ul class="first last simple">
<li>0: NRZ</li>
<li>1: Duo-binary</li>
<li>2: PAM-4</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">bandwidth        The bandwidth, at the summing node (Hz).</p>
</li>
<li><dl class="first docutils">
<dt>n_ave            The number of averages to take, before adapting.</dt>
<dd><p class="first last">(Also, the number of CDR adjustments per DFE adaptation.)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_lock_ave       The number of unit interval estimates to</dt>
<dd><p class="first last">consider, when determining locked status.</p>
</dd>
</dl>
</li>
<li><p class="first">rel_lock_tol     The relative tolerance for determining lock.</p>
</li>
<li><dl class="first docutils">
<dt>lock_sustain     Length of the histerysis vector used for</dt>
<dd><p class="first last">lock flagging.</p>
</dd>
</dl>
</li>
<li><p class="first">ideal            Boolean flag. When true, use an ideal summing node.</p>
</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code> &#8211;
If the requested modulation type is unknown.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pybert.dfe.DFE.decide">
<code class="descname">decide</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE.decide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE.decide" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the bit decisions, according to modulation type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>float</em>) &#8211; The signal value, at the decision time.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>tuple</strong> &#8211;
The members of the returned tuple are:<blockquote>
<div><dl class="docutils">
<dt>decision:</dt>
<dd>One of:<blockquote class="last">
<div><ul class="simple">
<li>{-1, 1}              (NRZ)</li>
<li>{-1, 0, +1}          (Duo-binary)</li>
<li>{-1, -1/3, +1/3, +1} (PAM-4)</li>
</ul>
<p>according to what the ideal signal level should have been.
(&#8216;decision_scaler&#8217; normalized)</p>
</div></blockquote>
</dd>
</dl>
<p>bits: The list of bits recovered.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float, [int]</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code> &#8211;
If the requested modulation type is unknown.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pybert.dfe.DFE.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>sample_times</em>, <em>signal</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the DFE on the input signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sample_times</strong> (<em>[float]</em>) &#8211; Vector of time values at wich
corresponding signal values were sampled.</li>
<li><strong>signal</strong> (<em>[float]</em>) &#8211; Vector of sampled signal values.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p><strong>tuple</strong> &#8211;
The members of the returned tuple, in order, are:</p>
<blockquote>
<div><dl class="docutils">
<dt>res([float]):</dt>
<dd><p class="first last">Samples of the summing node output, taken at the
times given in <em>sample_times</em>.</p>
</dd>
<dt>tap_weights([[float]]):</dt>
<dd><p class="first last">List of list of tap weights showing how the DFE
adapted over time.</p>
</dd>
<dt>ui_ests([float]):</dt>
<dd><p class="first last">List of unit interval estimates, showing how the
CDR adapted.</p>
</dd>
<dt>clocks([int]):</dt>
<dd><p class="first last">List of mostly zeros with ones at the recovered
clocking instants. Useful for overlaying the
clock times on signal waveforms, in plots.</p>
</dd>
<dt>lockeds([bool]):</dt>
<dd><p class="first last">List of Booleans indicating state of CDR lock.</p>
</dd>
<dt>clock_times([float]):</dt>
<dd><p class="first last">List of clocking instants, as recovered by the CDR.</p>
</dd>
<dt>bits([int]):</dt>
<dd><p class="first last">List of recovered bits.</p>
</dd>
</dl>
</div></blockquote>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">([float], [[float]], [float], [int], [bool], [float], [int]</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code> &#8211;
If the requested modulation type is unknown.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pybert.dfe.DFE.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>decision</em>, <em>error</em>, <em>update</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/dfe.html#DFE.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.dfe.DFE.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step the DFE, according to the new decision and error inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>decision</strong> (<em>float</em>) &#8211; Current slicer output.</li>
<li><strong>error</strong> (<em>float</em>) &#8211; Difference between summing node and slicer outputs.</li>
<li><strong>update</strong> (<em>bool</em>) &#8211; If true, update tap weights.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> &#8211;
New backward filter output value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pybert.cdr">
<span id="cdr-cdr-behavioral-model"></span><h2>cdr - CDR behavioral model.<a class="headerlink" href="#module-pybert.cdr" title="Permalink to this headline">¶</a></h2>
<p>Behavioral model of a &#8220;bang-bang&#8221; clock data recovery (CDR) unit.</p>
<p>Original Author: David Banas &lt;<a class="reference external" href="mailto:capn&#46;freako&#37;&#52;&#48;gmail&#46;com">capn<span>&#46;</span>freako<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Original Date:   17 June 2014</p>
<p>This Python script provides a behavioral model of a &#8220;bang-bang&#8221; clock
data recovery (CDR) unit. The class defined, here, is intended for
integration into the larger <em>PyBERT</em> framework.</p>
<p>Copyright (c) 2014 by David Banas; All rights reserved World wide.</p>
<dl class="class">
<dt id="pybert.cdr.CDR">
<em class="property">class </em><code class="descclassname">pybert.cdr.</code><code class="descname">CDR</code><span class="sig-paren">(</span><em>delta_t</em>, <em>alpha</em>, <em>ui</em>, <em>n_lock_ave=500</em>, <em>rel_lock_tol=0.01</em>, <em>lock_sustain=500</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/cdr.html#CDR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.cdr.CDR" title="Permalink to this definition">¶</a></dt>
<dd><p>A class providing behavioral modeling of a &#8216;bang- bang&#8217; clock
data recovery (CDR) unit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>delta_t</strong> (<em>float</em>) &#8211; The proportional branch correction, in seconds.</li>
<li><strong>alpha</strong> (<em>float</em>) &#8211; The integral branch correction, normalized to
proportional branch correction.</li>
<li><strong>ui</strong> (<em>float</em>) &#8211; The nominal unit interval, in seconds.</li>
<li><strong>n_lock_ave</strong> (<em>Optional, int</em>) &#8211; Number of unit intervals to use for
determining lock. Defaults to 500.</li>
<li><strong>rel_lock_tol</strong> (<em>Optional, float</em>) &#8211; Lock tolerance, relative to
<em>delta_t</em>. Defaults to 0.01.</li>
<li><strong>lock_sustain</strong> (<em>Optional, int</em>) &#8211; Length of lock sustain vector
used to provide histerysis. Defaults to 500.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The code does not care what units are actually used for
&#8216;delta_t&#8217; and &#8216;ui&#8217;; only that they are the same.</p>
<dl class="method">
<dt id="pybert.cdr.CDR.adapt">
<code class="descname">adapt</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pybert/cdr.html#CDR.adapt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pybert.cdr.CDR.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapt period/phase, according to 3 samples.</p>
<p>Should be called, when the clock has just struck.</p>
<dl class="docutils">
<dt>Synopsis:</dt>
<dd>(ui, locked) = adapt(samples)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>[float]</em>) &#8211; <p>A list of 3 samples of the input waveform, as follows:</p>
<ul class="simple">
<li>at the last clock time</li>
<li>at the last unit interval boundary time</li>
<li>at the current clock time</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>tuple</strong> &#8211;<dl class="docutils">
<dt>ui:</dt>
<dd>The new unit interval estimate, in seconds.</dd>
<dt>locked:</dt>
<dd>Boolean flag indicating &#8216;locked&#8217; status.</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float, bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pybert.cdr.CDR.locked">
<code class="descname">locked</code><a class="headerlink" href="#pybert.cdr.CDR.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>The current locked state.</p>
</dd></dl>

<dl class="attribute">
<dt id="pybert.cdr.CDR.ui">
<code class="descname">ui</code><a class="headerlink" href="#pybert.cdr.CDR.ui" title="Permalink to this definition">¶</a></dt>
<dd><p>The current unit interval estimate.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Modules in <em>pybert</em> package</a><ul>
<li><a class="reference internal" href="#module-pybert.pybert">pybert - Main <em>PyBERT</em> class definition, as well as some helper classes.</a></li>
<li><a class="reference internal" href="#module-pybert.pybert_cntrl">pybert_cntrl - Model control logic.</a></li>
<li><a class="reference internal" href="#module-pybert.pybert_view">pybert_view - Main GUI window layout definition.</a></li>
<li><a class="reference internal" href="#module-pybert.pybert_util">pybert_util - Various utilities used by other modules.</a></li>
<li><a class="reference internal" href="#module-pybert.pybert_plot">pybert_plot - Plot definitions for the <em>PyBERT</em> GUI.</a></li>
<li><a class="reference internal" href="#module-pybert.pybert_help">pybert_help - Contents of the <em>Help</em> tab of the <em>PyBERT</em> GUI.</a></li>
<li><a class="reference internal" href="#module-pybert.dfe">dfe - DFE behavioral model.</a></li>
<li><a class="reference internal" href="#module-pybert.cdr">cdr - CDR behavioral model.</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="intro.html"
                        title="previous chapter">General description of <em>pybert</em> package.</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/modules.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro.html" title="General description of pybert package."
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyBERT Developer Guide 2.0.5 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, David Banas.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>